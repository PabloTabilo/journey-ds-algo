<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on A Journey Through DS and Algorithms</title>
    <link>https://pablotabilo.github.io/journey-ds-algo/</link>
    <description>Recent content in Home on A Journey Through DS and Algorithms</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://pablotabilo.github.io/journey-ds-algo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Modular Exponentiation</title>
      <link>https://pablotabilo.github.io/journey-ds-algo/math/modular-exponentiation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://pablotabilo.github.io/journey-ds-algo/math/modular-exponentiation/</guid>
      <description>&lt;h1 id=&#34;modular-exponentiation&#34;&gt;&#xD;&#xA;  Modular Exponentiation&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#modular-exponentiation&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;Imagine you need to compute a value $a^e$ where $a&amp;gt;0$ and $e$ is a large positive integer. Calculating this directly can result in excessively large numbers, leading to overflow errors. To avoid this, we use modular arithmetic, where the result is calculated modulo a given number $m$. In mathematical terms, we aim to compute:&lt;/p&gt;&#xA;&lt;p&gt;$$a^e \mod m$$&lt;/p&gt;&#xA;&lt;p&gt;Where:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$a&amp;gt;0$ and $e&amp;gt;0$, both are integers.&lt;/li&gt;&#xA;&lt;li&gt;$m$ is the modulus, typically chosen to constrain the result within manageable bounds.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;why-modular-exponentiation-&#34;&gt;&#xD;&#xA;  Why Modular Exponentiation ?&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#why-modular-exponentiation-&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;For example, $2^{1000}$. Calculating this value directly would involve a massive number, making it computationally infeasible due to both time complexity and memory constraints. Modular exponentiation is a technique designed to handle this efficiently.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fermat&#39;s little Theorem</title>
      <link>https://pablotabilo.github.io/journey-ds-algo/math/fermats-little-theorem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://pablotabilo.github.io/journey-ds-algo/math/fermats-little-theorem/</guid>
      <description>&lt;h1 id=&#34;fermats-little-theorem&#34;&gt;&#xD;&#xA;  Fermat&amp;rsquo;s Little Theorem&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fermats-little-theorem&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;If $p$ is a prime number and $a$ is an integer such that $a$ is not divisible by $p$, then:&lt;/p&gt;&#xA;&lt;p&gt;$$a^{p-1} \equiv 1 \pmod{p}$$&lt;/p&gt;&#xA;&lt;h2 id=&#34;modular-inverse-using-fermats-little-theorem&#34;&gt;&#xD;&#xA;  Modular Inverse using Fermat&amp;rsquo;s Little Theorem&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#modular-inverse-using-fermats-little-theorem&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;The above theorem can be rearranged to give the modular inverse of $a$:&lt;/p&gt;&#xA;&lt;p&gt;$$a^{-1} \equiv a^{p-2} \pmod{p}$$&lt;/p&gt;&#xA;&lt;p&gt;This allows us to calculate the inverse of $a$ under modulo $p$, which is useful for division in modular arithmetic.&#xA;Example problem for use this technique: &lt;a href=&#34;https://codeforces.com/contest/2008/problem/F&#34;&gt;https://codeforces.com/contest/2008/problem/F&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Graphs</title>
      <link>https://pablotabilo.github.io/journey-ds-algo/data-structures/graphs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://pablotabilo.github.io/journey-ds-algo/data-structures/graphs/</guid>
      <description>&lt;h1 id=&#34;graph-problems&#34;&gt;&#xD;&#xA;  Graph Problems&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#graph-problems&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;Content for Graph Problems goes here.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Legendre&#39;s Formula</title>
      <link>https://pablotabilo.github.io/journey-ds-algo/math/legendres-formula/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://pablotabilo.github.io/journey-ds-algo/math/legendres-formula/</guid>
      <description>&lt;h1 id=&#34;legendres-formula&#34;&gt;&#xD;&#xA;  Legendre&amp;rsquo;s Formula&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#legendres-formula&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;Why we need to understand this technique?&#xA;Well in cses problem set is part of the introductory problems, and its a equation for build you abilities on math.&lt;/p&gt;&#xA;&lt;h2 id=&#34;problem-statement&#34;&gt;&#xD;&#xA;  Problem statement:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#problem-statement&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Remember that the original problem is here: &lt;a href=&#34;https://cses.fi/problemset/task/1618/&#34;&gt;https://cses.fi/problemset/task/1618/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;The task is to calculate the number of trailing zeros in the factorial $n!$.&#xA;For example, $20! = 2432902008176640000$ and it has 4 trailing zeros.&lt;/p&gt;&#xA;&lt;p&gt;If we wanna see the pattern its like this:&#xA;$$&#xA;\begin{aligned}&#xA;1! &amp;amp;= 1 \\&#xA;2! &amp;amp;= 2 \\&#xA;3! &amp;amp;= 6 \\&#xA;4! &amp;amp;= 24 \\&#xA;5! &amp;amp;= 120 \\&#xA;6! &amp;amp;= 720 \\&#xA;7! &amp;amp;= 5040 \\&#xA;8! &amp;amp;= 40320 \\&#xA;9! &amp;amp;= 362880 \\&#xA;10! &amp;amp;= 3628800 \\&#xA;11! &amp;amp;= 39916800 \\&#xA;12! &amp;amp;= 479001600 \\&#xA;13! &amp;amp;= 6227020800 \\&#xA;14! &amp;amp;= 87178291200 \\&#xA;15! &amp;amp;= 1307674368000 \\&#xA;16! &amp;amp;= 20922789888000&#xA;\end{aligned}&#xA;$$&lt;/p&gt;</description>
    </item>
    <item>
      <title>Segment Tree</title>
      <link>https://pablotabilo.github.io/journey-ds-algo/data-structures/segment-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://pablotabilo.github.io/journey-ds-algo/data-structures/segment-tree/</guid>
      <description>&lt;h1 id=&#34;segment-tree&#34;&gt;&#xD;&#xA;  Segment Tree&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#segment-tree&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;Content for Segment Tree problems goes here.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
