[{"id":0,"href":"/math/","title":"Math Problems","section":"Home","content":"\rMath Problems\r#\rTopics\r#\rModular Exponentiation Fermat\u0026rsquo;s Little Theorem legendre\u0026rsquo;s Formula "},{"id":1,"href":"/math/modular-exponentiation/","title":"Modular Exponentiation","section":"Math Problems","content":"\rModular Exponentiation\r#\rImagine you need to compute a value $a^e$ where $a\u0026gt;0$ and $e$ is a large positive integer. Calculating this directly can result in excessively large numbers, leading to overflow errors. To avoid this, we use modular arithmetic, where the result is calculated modulo a given number $m$. In mathematical terms, we aim to compute:\n$$a^e \\mod m$$\nWhere:\n$a\u0026gt;0$ and $e\u0026gt;0$, both are integers. $m$ is the modulus, typically chosen to constrain the result within manageable bounds. Why Modular Exponentiation ?\r#\rFor example, $2^{1000}$. Calculating this value directly would involve a massive number, making it computationally infeasible due to both time complexity and memory constraints. Modular exponentiation is a technique designed to handle this efficiently.\nThe Logic behind\r#\rThe method relies on divide-and-conquer principles while leveraging properties of modular arithmetic to simplify intermediate results. This approach reduces the computational complexity from $O(e)$ to $O(\\log e )$, making it significantly faster.\nLetâ€™s break it down using an example: compute $2^9 \\pmod{10^9 + 1}$.\nWe know:\n$$2^9 = 2\\cdot2^8 = 2\\cdot(2^4)^2$$\nThe idea is to take advantage of the parity (odd or even nature) of the exponent.\nif $e$ is odd, $a^e = a\\cdot a^{e-1}$. if $e$ is even, $a^e = (a^{e/2})^2$. This recursive pattern forms the basis of the iterative implementation of modular exponentiation.\nAlgorithm\r#\rlong long modularExponentiation(long long base, long long exp, long long mod) { long long result = 1; while (exp \u0026gt; 0) { if (exp % 2 == 1) { result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } "},{"id":2,"href":"/data-structures/","title":"Data Structures Problems","section":"Home","content":"\rData Structures Problems\r#\rTopics\r#\rDSU - Union and Find Segment Tree Graphs "},{"id":3,"href":"/math/fermats-little-theorem/","title":"Fermat's little Theorem","section":"Math Problems","content":"\rFermat\u0026rsquo;s Little Theorem\r#\rIf $p$ is a prime number and $a$ is an integer such that $a$ is not divisible by $p$, then:\n$$a^{p-1} \\equiv 1 \\pmod{p}$$\nModular Inverse using Fermat\u0026rsquo;s Little Theorem\r#\rThe above theorem can be rearranged to give the modular inverse of $a$:\n$$a^{-1} \\equiv a^{p-2} \\pmod{p}$$\nThis allows us to calculate the inverse of $a$ under modulo $p$, which is useful for division in modular arithmetic. Example problem for use this technique: https://codeforces.com/contest/2008/problem/F\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; using pii = pair\u0026lt;int,int\u0026gt;; const int M = 1e9 + 7; // Modular inverse ll modularExponentiation(ll base, ll exp, ll mod){ ll result = 1; while(exp \u0026gt; 0){ if(exp % 2 == 1){ result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); ll S = 0; for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; a[i]; S = (S + a[i]) % M; } ll P = 0; for(int i=0;i\u0026lt;n;i++){ P = (P % M + (a[i] * (S - a[i] + M) ) % M ) % M; } P = ( P * mod_exp(2, M-2, M) ) % M; // P * 2^{-1} ll Q = (1LL * n * (n - 1) / 2) % M; ll Q_inv = mod_exp(Q, M-2, M); // Q^{-1} ll ans = (P * Q_inv) % M; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } "},{"id":4,"href":"/data-structures/graphs/","title":"Graphs","section":"Data Structures Problems","content":"\rGraph Problems\r#\rContent for Graph Problems goes here.\n"},{"id":5,"href":"/math/legendres-formula/","title":"Legendre's Formula","section":"Math Problems","content":"\rLegendre\u0026rsquo;s Formula\r#\rWhy we need to understand this technique? Well in cses problem set is part of the introductory problems, and its a equation for build you abilities on math.\nProblem statement:\r#\rRemember that the original problem is here: https://cses.fi/problemset/task/1618/\nThe task is to calculate the number of trailing zeros in the factorial $n!$. For example, $20! = 2432902008176640000$ and it has 4 trailing zeros.\nIf we wanna see the pattern its like this: $$ \\begin{aligned} 1! \u0026amp;= 1 \\ 2! \u0026amp;= 2 \\ 3! \u0026amp;= 6 \\end{aligned} $$\n"},{"id":6,"href":"/data-structures/segment-tree/","title":"Segment Tree","section":"Data Structures Problems","content":"\rSegment Tree\r#\rContent for Segment Tree problems goes here.\n"}]