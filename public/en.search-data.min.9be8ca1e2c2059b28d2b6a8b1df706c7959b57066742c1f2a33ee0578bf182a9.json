[{"id":0,"href":"/math/arithmetic-counting-and-modulus/","title":"Arithmetic, counting and modulus operations","section":"Math Problems","content":"\rArithmetic, counting and modulus operations\r#\rIn this article, we aim to enhance our pattern recognition abilities by leveraging fundamental mathematical skills such as arithmetic, counting, and modulus operations.\nTo begin, we will explore a problem that encourages a deeper understanding of these techniques. This problem, known as Digit Queries, is part of the CSES problem set.\nDigit Queries - Problem statement\r#\rConsider an infinite string that consist of all positive integer in increasing order: 12345678910111213141516171819202122232425... Your task is to process $q$ queries of the form: what\u0026rsquo;s the digit at position $k$ in the string?\nConstraints\n$1 \\le q \\le 1000$ $1 \\le k \\le 10^{18}$ For example, if a query asks for the digit at position $k = 7$, we need to return 7. Why? Because the $7^{th}$ position in the infinite string 1234567... is indeed 7.\nAnother example: if $k = 12$, we must return 1 since the $12^{th}$ digit of the string 123456789101... is 1.\nAs a final example, consider $k = 19$. We need to return 4 because in the string 1234567891011121314..., the $19^{th}$ digit is 4.\nThoughts\r#\rThe string is infinite, so we cannot fully generate or store it. Instead, we need to identify patterns or make \u0026ldquo;jumps\u0026rdquo; through the sequence of digits.\nIf we consider the numbers grouped by their digit lengths:\n123456789 (1-digit numbers) 10111213141516171819202122...9899 (2-digit numbers) 100101102103104...998999 (3-digit numbers) ... and so forth For each digit length $d$, the total number of digits in that block can be expressed as:\n$$ block_d = 9 \\cdot 10^{d-1} \\cdot d $$\nFor example:\nIf $d = 1$, then $block_1 = 9 \\cdot 10^0 \\cdot 1 = 9$ digits. If $d = 2$, then $block_2 = 9 \\cdot 10^1 \\cdot 2 = 180$ digits. If $d = 3$, then $block_3 = 9 \\cdot 10^2 \\cdot 3 = 2700$ digits. Did you see the pattern?, its like we can build some solution that runs on $O(\\log_{10}(k))$.\nWe also know the starting point (the first number) for each block:\nIf $d = 1$, then $start = 1$ If $d = 2$, then $start = 10$ If $d = 3$, then $start = 100$ \u0026hellip; and so on.\nWith this information, we can find the specific number $num_k$ that contains the digit at position $k$:\n$$ num_k = start + \\frac{(k_{block_d} - 1)}{d} $$\nHere, $k_{block_d}$ is the position $k$ adjusted to the current digit block. We cannot use the raw $k^{th}$ position directly because we must first exclude all the digits from previous blocks.\nFor example, if $k = 19$, the first 9 digits are from the 1-digit block, leaving $k_{block_2} = 19 - 9 = 10$. Since the 2-digit block starts right after those 9 digits, we move forward within this block. We use $k_{block_2} - 1 = 9$ to determine how far into the 2-digit sequence we go, and in this case, $num_k = 14$.\nAfter finding $num_k$, we identify the exact digit with a modulus operation: $$ digitIndex = (k - 1) \\mod d $$\nWe then convert $num_k$ to a string and extract the character at digitIndex, num_k[digitIndex].\nCode\r#\r#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int q; cin \u0026gt;\u0026gt; q; while(q--){ ll k; cin \u0026gt;\u0026gt; k; ll d = 1; ll tot = 9 * d; ll ten = 1; while(tot \u0026lt; k){ k -= tot; d++; ten *= 10; tot = 9 * d * ten; } // numk = 99 -\u0026gt; d = 2 // nunk = 100 -\u0026gt; d = 3 // k \u0026gt;\u0026gt; iam here -\u0026gt; d // floor(k-1/d) ll numk = ten + (k-1)/d; ll i = (k-1)%d; string s = to_string(numk); //cout \u0026lt;\u0026lt; \u0026#34;k = \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34;, ten = \u0026#34; \u0026lt;\u0026lt; ten \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;numk = \u0026#34; \u0026lt;\u0026lt; numk \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s[i] \u0026lt;\u0026lt; endl; } return 0; } References\r#\rDigit Queries problem: https://cses.fi/problemset/task/2431/ "},{"id":1,"href":"/dynamic-programming-problems/dp-level-1/","title":"DP Level 1","section":"Dynamic Programming Problems","content":"\rDP Level 1\r#\rLet\u0026rsquo;s start by looking at this LeetCode problem to help you understand the core concepts. Together we\u0026rsquo;ll explore the different techniques and data structures you can use to solve it effectively.\n2466. Count Ways To Build Good Strings\r#\rLevel medium. Problem statement\r#\rGiven the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:\nAppend the character \u0026lsquo;0\u0026rsquo; zero times. Append the character \u0026lsquo;1\u0026rsquo; one times. This can be performed any number of times. A good string is a string constructed by the above process having a length between low and high (inclusive).\nReturn the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo $10^9 + 7$.\nExample 1:\r#\rInput: low = 3, high = 3, zero = 1, one = 1\rOutput: 8 Explanation:\nOne possible valid good string is \u0026ldquo;011\u0026rdquo;. It can be constructed as follows: \u0026quot;\u0026quot; -\u0026gt; \u0026ldquo;0\u0026rdquo; -\u0026gt; \u0026ldquo;01\u0026rdquo; -\u0026gt; \u0026ldquo;011\u0026rdquo;. All binary strings from \u0026ldquo;000\u0026rdquo; to \u0026ldquo;111\u0026rdquo; are good strings in this example. Example 2:\r#\rInput: low = 2, high = 3, zero = 1, one = 2\rOutput: 5 Explanation:\nThe good strings are \u0026ldquo;00\u0026rdquo;, \u0026ldquo;11\u0026rdquo;, \u0026ldquo;000\u0026rdquo;, \u0026ldquo;110\u0026rdquo;, and \u0026ldquo;011\u0026rdquo;. Constraints:\r#\r$1 \\le low \\le high \\le 10^5$ $1 \\le zero, one \\le low$ First Thoughts\r#\rMy first implementation was a recursion solution, because for me its more intuitive to see the relationship structure between the branch\u0026rsquo;s of each node. Here\u0026rsquo;s the code:\nclass Solution { public: int low, high, zero, one; int ans = 0; void f(int sz, string\u0026amp; s){ if(sz \u0026gt;= low \u0026amp;\u0026amp; sz \u0026lt;= high){ cout \u0026lt;\u0026lt;\u0026#34;permutation:\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; ans++; } if(sz \u0026gt; high){ return; } for(int k=1;k\u0026lt;=zero;k++) s.push_back(\u0026#39;0\u0026#39;); f(sz+zero, s); for(int k=1;k\u0026lt;=zero;k++) s.pop_back(); for(int k=1;k\u0026lt;=one;k++) s.push_back(\u0026#39;1\u0026#39;); f(sz+one, s); for(int k=1;k\u0026lt;=one;k++) s.pop_back(); } int countGoodStrings(int low, int high, int zero, int one) { this-\u0026gt;low = low; this-\u0026gt;high = high; this-\u0026gt;zero = zero; this-\u0026gt;one = one; string permutation = \u0026#34;\u0026#34;; f(0, permutation); return ans; } }; The code works, but the time complexity is horrible like $O(2^n)$ and not forget that for each node I add char a time defined by one or zero to a string for debugging.\nThe first think you can view its like the structure of solve the problem its the same for that reason i can use a f(sz) function.\nThe second thing is like always we advance to forward because on the future i\u0026rsquo;am gonna have my solution.\nSo for create the new node or the next step of my algorithm i am only need to calculte or process current.\nThe low and high variables are like restrictions.\nThe zero and one variables are like jumps to reach the next factible node.\nSubmissions Results\r#\rReferences:\r#\rProblem: https://leetcode.com/problems/count-ways-to-build-good-strings/?envType=daily-question\u0026envId=2024-12-30 "},{"id":2,"href":"/searching-and-sorting/easy-sort-problem/","title":"Easy Sort Problem","section":"Searching And Sorting Problems","content":"\rStarting with Sorting Problems\r#\rLet\u0026rsquo;s start by looking at this LeetCode problem to help you understand the core concepts. Together we\u0026rsquo;ll explore the different techniques and data structures you can use to solve it effectively.\n2593 - Find Score of An Array After Marking All Elements\r#\rLevel medium. Problem statement\r#\rYou are given an array nums consisting of positive integers.\nStarting with score = 0, apply the following algorithm:\nChoose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index. Add the value of the chosen integer to score. Mark the chosen element and its two adjacent elements if they exist. Repeat until all the array elements are marked. Return the score you get after applying the above algorithm.\nExample 1:\nInput: nums = [2,1,3,4,5,2] Output: 7 Explanation: We mark the elements as follows:\n1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2]. 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2]. 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2]. Our score is 1 + 2 + 4 = 7. Example 2: Input: nums = [2,3,5,1,3,2] Output: 5 Explanation: We mark the elements as follows:\n1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2]. 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2]. 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2]. Our score is 1 + 2 + 2 = 5. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 106\nThoughts\r#\rApproach 1\r#\rclass Solution { static class Pair implements Comparable\u0026lt;Pair\u0026gt;{ int num; int index; Pair(int num, int index){ this.num = num; this.index = index; } @Override public int compareTo(Pair other){ if(this.num != other.num){ return Integer.compare(this.num, other.num); } return Integer.compare(this.index, other.index); } } public long findScore(int[] nums) { long ans = 0; TreeSet\u0026lt;Pair\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); int n = nums.length; for(int i=0;i\u0026lt;n;i++){ set.add(new Pair(nums[i], i)); } while(!set.isEmpty()){ Pair p = set.pollFirst(); ans += (long) p.num; int idx = p.index; if(idx + 1 \u0026lt; n){ set.remove(new Pair(nums[idx+1],idx+1)); } if(idx - 1 \u0026gt;= 0){ set.remove(new Pair(nums[idx-1],idx-1)); } } return ans; } } Approach 2\r#\rclass Solution { public long findScore(int[] nums) { long ans = 0; int n = nums.length; int [][] sorted = new int[n][2]; boolean [] marked = new boolean[n]; for(int i=0;i\u0026lt;n;i++){ sorted[i][0] = nums[i]; sorted[i][1] = i; } Arrays.sort(sorted, (arr1, arr2) -\u0026gt; arr1[0] - arr2[0]); for(int i=0;i\u0026lt;n;i++){ int num = sorted[i][0]; int idx = sorted[i][1]; if(!marked[idx]){ ans += (long) num; marked[idx] = true; if(idx-1 \u0026gt;= 0){ marked[idx-1]=true; } if(idx+1 \u0026lt; n){ marked[idx+1]=true; } } } return ans; } } Submissions Results\r#\rReferences:\r#\rProblem: https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/description/ TreeSet data structure on java: https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html "},{"id":3,"href":"/searching-and-sorting/","title":"Searching And Sorting Problems","section":"Home","content":"\rSearching and Sorting\r#\rTo understand this type of problem, we need to consider cases where a specific permutation of the array or vector might be beneficial for us. If such a permutation has the characteristic that its elements are ordered monotonically, we can implement a sorting algorithm to achieve this order.\nWhen it comes to the searching phase, it\u0026rsquo;s important to note that scanning an array of size n in the worst case takes $O(n)$ time. For large constraints, such as an array of size $10^9$, this becomes computationally infeasible, as scanning such an array empirically takes more than 1 second. Generally, if a solution takes too long to execute, it results in an error commonly known as TLE (Time Limit Exceeded).\nTable of Contents\r#\reasy sort problem "},{"id":4,"href":"/data-structures/","title":"Data Structures Problems","section":"Home","content":"\rData Structures Problems\r#\rTopics\r#\rDSU - Union and Find Segment Tree Graphs "},{"id":5,"href":"/math/legendres-formula/","title":"Legendre's Formula","section":"Math Problems","content":"\rLegendre\u0026rsquo;s Formula\r#\rWhy do we need to understand this technique?\nIn the CSES Problem Set, it is part of the introductory problems and serves as a foundational equation for building mathematical skills.\nProblem Statement:\r#\rThe original problem can be found here: CSES Problem 1618.\nThe task is to calculate the number of trailing zeros in the factorial $n!$. For example, $20! = 2432902008176640000$, which has 4 trailing zeros.\nIf we analyze the pattern, it looks like this:\n$$ \\begin{align*} 1! \u0026amp;= 1 \\\\ 2! \u0026amp;= 2 \\\\ 3! \u0026amp;= 6 \\\\ 4! \u0026amp;= 24 \\\\ 5! \u0026amp;= 120 \\\\ 6! \u0026amp;= 720 \\\\ 7! \u0026amp;= 5040 \\\\ 8! \u0026amp;= 40320 \\\\ 9! \u0026amp;= 362880 \\\\ 10! \u0026amp;= 3628800 \\\\ 11! \u0026amp;= 39916800 \\\\ 12! \u0026amp;= 479001600 \\\\ 13! \u0026amp;= 6227020800 \\\\ 14! \u0026amp;= 87178291200 \\\\ 15! \u0026amp;= 1307674368000 \\\\ 16! \u0026amp;= 20922789888000 \\end{align*} $$\nEvery multiple of 5 seems to add a trailing zero. But why does this happen?\nThis is because to add a zero to any number, we need $5 \\cdot 2 = 10$. Thus, every pair $(5, 2)$ contributes a trailing zero.\nFor instance:\n$$6! = 1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 \\cdot 6 = 2^4 \\cdot 3^2 \\cdot 5.$$\nFinally, to find the number of trailing zeros, we calculate: $$\\text{min}(x, y)$$ where:\n$x$ is the number of times (or the exponent) of the prime 2 is multiplied. (e.g., for 6, $x = 4$). $y$ is the number of times (or the exponent) of the prime 5 is multiplied. (e.g., for 6, $y = 1$). Thus, for $6$, $\\text{min}(x=4, y=1) = 1$, which is the trailing zero for this case.\nHere is where Legendre\u0026rsquo;s Formula comes in, as it provides an expression for the exponent of the largest power of a prime $p$ that divides the factorial $n!$:\n$$ v_p(n!) = \\sum_{i=1}^\\infty \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor $$\nWhere:\n$n$ is the factorial. $p$ is the prime. $\\lfloor x \\rfloor$ is the floor function. We can simplify the formula since if $p^i \u0026gt; n$, then $\\left\\lfloor \\frac{n}{p^i} \\right\\rfloor = 0$.\nThus: $$ v_p(n!) = \\sum_{i=1}^L \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor $$\nAnd: $$ L = \\lfloor \\log_p(n) \\rfloor $$\nIf we revisit $6!$, where $6! = 2^4 \\cdot 3^2 \\cdot 5$, we can calculate:\n$$ \\begin{align*} v_2(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_2(6) \\rfloor = 2} \\left\\lfloor \\frac{6}{2^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{2} \\right\\rfloor + \\left\\lfloor \\frac{6}{4} \\right\\rfloor = 3 + 1 = 4, \\\\ v_3(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_3(6) \\rfloor = 1} \\left\\lfloor \\frac{6}{3^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{3} \\right\\rfloor = 2, \\\\ v_5(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_5(6) \\rfloor = 1} \\left\\lfloor \\frac{6}{5^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{5} \\right\\rfloor = 1. \\end{align*} $$\nCode\r#\rThe time complexity is $O(\\log_p n)$, where $p$ is the prime, and the space complexity is $O(1)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; // Remember: for a \u0026#34;0\u0026#34; to exist, there must be a 10 or 2*5 primes // Legendre\u0026#39;s formula int cnt = 0; for(int i = 5; (n / i) \u0026gt; 0; i *= 5){ cnt += (n / i); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } References\r#\rhttps://en.wikipedia.org/wiki/Legendre%27s_formula "},{"id":6,"href":"/dynamic-programming-problems/","title":"Dynamic Programming Problems","section":"Home","content":"\rDynamic Programming Problems\r#\rTo understand this type of problem, the first step is to identified the characteristics. For example:\nIt\u0026rsquo;s a maximum / minimum problem? Do I need to count a number of events? Can this problem be solve using recursion? Does the solution follow the same properties or structure, independent of the problem\u0026rsquo;s size? In your implementation on the recursive function, is there a specific order require to process the solution? Table of Contents\r#\rDP level 1 "},{"id":7,"href":"/math/modular-exponentiation/","title":"Modular Exponentiation","section":"Math Problems","content":"\rModular Exponentiation\r#\rImagine you need to compute a value $a^e$ where $a\u0026gt;0$ and $e$ is a large positive integer. Calculating this directly can result in excessively large numbers, leading to overflow errors. To avoid this, we use modular arithmetic, where the result is calculated modulo a given number $m$. In mathematical terms, we aim to compute:\n$$a^e \\mod m$$\nWhere:\n$a\u0026gt;0$ and $e\u0026gt;0$, both are integers. $m$ is the modulus, typically chosen to constrain the result within manageable bounds. Why Modular Exponentiation ?\r#\rFor example, $2^{1000}$. Calculating this value directly would involve a massive number, making it computationally infeasible due to both time complexity and memory constraints. Modular exponentiation is a technique designed to handle this efficiently.\nThe Logic behind\r#\rThe method relies on divide-and-conquer principles while leveraging properties of modular arithmetic to simplify intermediate results. This approach reduces the computational complexity from $O(e)$ to $O(\\log e )$, making it significantly faster.\nLet’s break it down using an example: compute $2^9 \\pmod{10^9 + 1}$.\nWe know:\n$$2^9 = 2\\cdot2^8 = 2\\cdot(2^4)^2$$\nThe idea is to take advantage of the parity (odd or even nature) of the exponent.\nif $e$ is odd, $a^e = a\\cdot a^{e-1}$. if $e$ is even, $a^e = (a^{e/2})^2$. This recursive pattern forms the basis of the iterative implementation of modular exponentiation.\nAlgorithm\r#\rlong long modularExponentiation(long long base, long long exp, long long mod) { long long result = 1; while (exp \u0026gt; 0) { if (exp % 2 == 1) { result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } Example Problems\r#\rhttps://cses.fi/problemset/task/1617/ We need use this technique, but it\u0026rsquo;s not the complete concept to understand the problem: https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-ii/description/ "},{"id":8,"href":"/math/fermats-little-theorem/","title":"Fermat's little Theorem","section":"Math Problems","content":"\rFermat\u0026rsquo;s Little Theorem\r#\rIf $p$ is a prime number and $a$ is an integer such that $a$ is not divisible by $p$, then:\n$$a^{p-1} \\equiv 1 \\pmod{p}$$\nModular Inverse using Fermat\u0026rsquo;s Little Theorem\r#\rThe above theorem can be rearranged to give the modular inverse of $a$:\n$$a^{-1} \\equiv a^{p-2} \\pmod{p}$$\nThis allows us to calculate the inverse of $a$ under modulo $p$, which is useful for division in modular arithmetic. Example problem for use this technique: https://codeforces.com/contest/2008/problem/F\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; using pii = pair\u0026lt;int,int\u0026gt;; const int M = 1e9 + 7; // Modular inverse ll modularExponentiation(ll base, ll exp, ll mod){ ll result = 1; while(exp \u0026gt; 0){ if(exp % 2 == 1){ result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); ll S = 0; for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; a[i]; S = (S + a[i]) % M; } ll P = 0; for(int i=0;i\u0026lt;n;i++){ P = (P % M + (a[i] * (S - a[i] + M) ) % M ) % M; } P = ( P * mod_exp(2, M-2, M) ) % M; // P * 2^{-1} ll Q = (1LL * n * (n - 1) / 2) % M; ll Q_inv = mod_exp(Q, M-2, M); // Q^{-1} ll ans = (P * Q_inv) % M; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } "},{"id":9,"href":"/math/","title":"Math Problems","section":"Home","content":"\rMath Problems\r#\rTopics\r#\rArithmetic, counting and modulus operations Modular Exponentiation Fermat\u0026rsquo;s Little Theorem legendre\u0026rsquo;s Formula "},{"id":10,"href":"/data-structures/dequeue/","title":"Dequeue","section":"Data Structures Problems","content":"\rDequeue\r#\rWhat\u0026rsquo;s a dequeue?\r#\rIs a generalize version of a queue with double Ended, where we can insert and delete elements at boths sides.\nSo, in any problem when we need to pop or push elements fast on $O(1)$ this data structure is very util.\nProblem - find longest special substring that occurs thrice I\r#\rYou are given a string s that consists of lowercase English letters.\nA string is called special if its made up of only a single character. For example, the string abc is not special, whereas the string ddd, zz and f are special.\nReturn the length of the longest special substrings of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.\nA substrings is a contiguous non-empty sequence of characters within a string.\nExample test case 1:\r#\rInput: s = \u0026quot;aaaa\u0026quot; Output: 2\nExplanation:\nIf $k = 1$, so i have {{a}, {a}, {a}, {a}}, and repeat more than 3 times. Its a factible answer. If $k = 2$, so i have {{aa}, {aa}, {aa}}, and repeat more than 3 times. Its a factible answer and the best at moment. If $k = 3$, so i have {{aaa}, {aaa}}, and repeat more than 3 times. Its not a factible answer. Thoughts\r#\rOk, the substring must be contiguous and not empty, so the combinations must be adjacents chars. If i need calculate combinations that are adjacent on a string may be i can use sliding windows Ok, but for sliding window if i wanna pop and push chars from front or end to my temporal contiguos substrings of size k, the time complexity gonna up if i try to insert elements or chars on front. Remember that the operation += do it on a string, create a copy of the object. That\u0026rsquo;s occupied time and memory. So if i only want get a track of the chars that are on my window, i can use a deque\u0026lt;char\u0026gt; and pop or push fast. References:\r#\rlink to the original problem: https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/description/ "},{"id":11,"href":"/data-structures/graphs/","title":"Graphs","section":"Data Structures Problems","content":"\rGraph Problems\r#\rContent for Graph Problems goes here.\n"},{"id":12,"href":"/data-structures/segment-tree/","title":"Segment Tree","section":"Data Structures Problems","content":"\rSegment Tree\r#\rContent for Segment Tree problems goes here.\n"}]