[{"id":0,"href":"/math/","title":"Math Problems","section":"Home","content":"\rMath Problems\r#\rTopics\r#\rModular Exponentiation Fermat\u0026rsquo;s Little Theorem legendre\u0026rsquo;s Formula "},{"id":1,"href":"/math/modular-exponentiation/","title":"Modular Exponentiation","section":"Math Problems","content":"\rModular Exponentiation\r#\rImagine you need to compute a value $a^e$ where $a\u0026gt;0$ and $e$ is a large positive integer. Calculating this directly can result in excessively large numbers, leading to overflow errors. To avoid this, we use modular arithmetic, where the result is calculated modulo a given number $m$. In mathematical terms, we aim to compute:\n$$a^e \\mod m$$\nWhere:\n$a\u0026gt;0$ and $e\u0026gt;0$, both are integers. $m$ is the modulus, typically chosen to constrain the result within manageable bounds. Why Modular Exponentiation ?\r#\rFor example, $2^{1000}$. Calculating this value directly would involve a massive number, making it computationally infeasible due to both time complexity and memory constraints. Modular exponentiation is a technique designed to handle this efficiently.\nThe Logic behind\r#\rThe method relies on divide-and-conquer principles while leveraging properties of modular arithmetic to simplify intermediate results. This approach reduces the computational complexity from $O(e)$ to $O(\\log e )$, making it significantly faster.\nLetâ€™s break it down using an example: compute $2^9 \\pmod{10^9 + 1}$.\nWe know:\n$$2^9 = 2\\cdot2^8 = 2\\cdot(2^4)^2$$\nThe idea is to take advantage of the parity (odd or even nature) of the exponent.\nif $e$ is odd, $a^e = a\\cdot a^{e-1}$. if $e$ is even, $a^e = (a^{e/2})^2$. This recursive pattern forms the basis of the iterative implementation of modular exponentiation.\nAlgorithm\r#\rlong long modularExponentiation(long long base, long long exp, long long mod) { long long result = 1; while (exp \u0026gt; 0) { if (exp % 2 == 1) { result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } Example Problems\r#\rhttps://cses.fi/problemset/task/1617/ We need use this technique, but it\u0026rsquo;s not the complete concept to understand the problem: https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-ii/description/ "},{"id":2,"href":"/data-structures/","title":"Data Structures Problems","section":"Home","content":"\rData Structures Problems\r#\rTopics\r#\rDSU - Union and Find Segment Tree Graphs "},{"id":3,"href":"/math/fermats-little-theorem/","title":"Fermat's little Theorem","section":"Math Problems","content":"\rFermat\u0026rsquo;s Little Theorem\r#\rIf $p$ is a prime number and $a$ is an integer such that $a$ is not divisible by $p$, then:\n$$a^{p-1} \\equiv 1 \\pmod{p}$$\nModular Inverse using Fermat\u0026rsquo;s Little Theorem\r#\rThe above theorem can be rearranged to give the modular inverse of $a$:\n$$a^{-1} \\equiv a^{p-2} \\pmod{p}$$\nThis allows us to calculate the inverse of $a$ under modulo $p$, which is useful for division in modular arithmetic. Example problem for use this technique: https://codeforces.com/contest/2008/problem/F\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; using pii = pair\u0026lt;int,int\u0026gt;; const int M = 1e9 + 7; // Modular inverse ll modularExponentiation(ll base, ll exp, ll mod){ ll result = 1; while(exp \u0026gt; 0){ if(exp % 2 == 1){ result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); ll S = 0; for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; a[i]; S = (S + a[i]) % M; } ll P = 0; for(int i=0;i\u0026lt;n;i++){ P = (P % M + (a[i] * (S - a[i] + M) ) % M ) % M; } P = ( P * mod_exp(2, M-2, M) ) % M; // P * 2^{-1} ll Q = (1LL * n * (n - 1) / 2) % M; ll Q_inv = mod_exp(Q, M-2, M); // Q^{-1} ll ans = (P * Q_inv) % M; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } "},{"id":4,"href":"/data-structures/graphs/","title":"Graphs","section":"Data Structures Problems","content":"\rGraph Problems\r#\rContent for Graph Problems goes here.\n"},{"id":5,"href":"/math/legendres-formula/","title":"Legendre's Formula","section":"Math Problems","content":"\rLegendre\u0026rsquo;s Formula\r#\rWhy do we need to understand this technique?\nIn the CSES Problem Set, it is part of the introductory problems and serves as a foundational equation for building mathematical skills.\nProblem Statement:\r#\rThe original problem can be found here: CSES Problem 1618.\nThe task is to calculate the number of trailing zeros in the factorial $n!$. For example, $20! = 2432902008176640000$, which has 4 trailing zeros.\nIf we analyze the pattern, it looks like this:\n$$ \\begin{align*} 1! \u0026amp;= 1 \\\\ 2! \u0026amp;= 2 \\\\ 3! \u0026amp;= 6 \\\\ 4! \u0026amp;= 24 \\\\ 5! \u0026amp;= 120 \\\\ 6! \u0026amp;= 720 \\\\ 7! \u0026amp;= 5040 \\\\ 8! \u0026amp;= 40320 \\\\ 9! \u0026amp;= 362880 \\\\ 10! \u0026amp;= 3628800 \\\\ 11! \u0026amp;= 39916800 \\\\ 12! \u0026amp;= 479001600 \\\\ 13! \u0026amp;= 6227020800 \\\\ 14! \u0026amp;= 87178291200 \\\\ 15! \u0026amp;= 1307674368000 \\\\ 16! \u0026amp;= 20922789888000 \\end{align*} $$\nEvery multiple of 5 seems to add a trailing zero. But why does this happen?\nThis is because to add a zero to any number, we need $5 \\cdot 2 = 10$. Thus, every pair $(5, 2)$ contributes a trailing zero.\nFor instance:\n$$6! = 1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 \\cdot 6 = 2^4 \\cdot 3^2 \\cdot 5.$$\nFinally, to find the number of trailing zeros, we calculate: $$\\text{min}(x, y)$$ where: $$ \\begin{array}{l} \\bullet \\ x \\text{ is the number of times (or the exponent) the prime } 2 \\text{ is multiplied (e.g., for } 6, , x = 4). \\\\ \\bullet \\ y \\text{ is the number of times (or the exponent) the prime } 5 \\text{ is multiplied (e.g., for } 6, , y = 1). \\\\ \\end{array} $$\nThus, for $6$, $\\text{min}(x=4, y=1) = 1$, which is the trailing zero for this case.\nHere is where Legendre\u0026rsquo;s Formula comes in, as it provides an expression for the exponent of the largest power of a prime $p$ that divides the factorial $n!$:\n$$ v_p(n!) = \\sum_{i=1}^\\infty \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor $$\nWhere:\n$n$ is the factorial. $p$ is the prime. $\\lfloor x \\rfloor$ is the floor function. We can simplify the formula since if $p^i \u0026gt; n$, then $\\left\\lfloor \\frac{n}{p^i} \\right\\rfloor = 0$.\nThus: $$ v_p(n!) = \\sum_{i=1}^L \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor $$\nAnd: $$ L = \\lfloor \\log_p(n) \\rfloor $$\nIf we revisit $6!$, where $6! = 2^4 \\cdot 3^2 \\cdot 5$, we can calculate:\n$$ \\begin{align*} v_2(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_2(6) \\rfloor = 2} \\left\\lfloor \\frac{6}{2^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{2} \\right\\rfloor + \\left\\lfloor \\frac{6}{4} \\right\\rfloor = 3 + 1 = 4, \\\\ v_3(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_3(6) \\rfloor = 1} \\left\\lfloor \\frac{6}{3^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{3} \\right\\rfloor = 2, \\\\ v_5(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_5(6) \\rfloor = 1} \\left\\lfloor \\frac{6}{5^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{5} \\right\\rfloor = 1. \\end{align*} $$\nCode\r#\rThe time complexity is $O(\\log_p n)$, where $p$ is the prime, and the space complexity is $O(1)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; // Remember: for a \u0026#34;0\u0026#34; to exist, there must be a 10 or 2*5 primes // Legendre\u0026#39;s formula int cnt = 0; for(int i = 5; (n / i) \u0026gt; 0; i *= 5){ cnt += (n / i); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } References\r#\rhttps://en.wikipedia.org/wiki/Legendre%27s_formula "},{"id":6,"href":"/data-structures/segment-tree/","title":"Segment Tree","section":"Data Structures Problems","content":"\rSegment Tree\r#\rContent for Segment Tree problems goes here.\n"}]