[{"id":0,"href":"/journey-ds-algo/math/","title":"Math Problems","section":"Home","content":"\rMath Problems\r#\rTopics\r#\rModular Exponentiation Fermat\u0026rsquo;s Little Theorem "},{"id":1,"href":"/journey-ds-algo/data-structures/","title":"Data Structures Problems","section":"Home","content":"\rData Structures Problems\r#\rTopics\r#\rDSU - Union and Find Segment Tree Graphs "},{"id":2,"href":"/journey-ds-algo/data-structures/graphs/","title":"Graphs","section":"Data Structures Problems","content":"\rGraph Problems\r#\rContent for Graph Problems goes here.\n"},{"id":3,"href":"/journey-ds-algo/math/modular-exponentiation/","title":"Modular Exponentiation","section":"Math Problems","content":"\rModular Exponentiation\r#\rImagine you need to compute a value $a^e$ where $a \u0026gt; 0$ and $e$ is a large positive integer. Calculating this directly can result in excessively large numbers, leading to overflow errors.\nWhy Modular Exponentiation?\r#\rFor example, $2^{1000}$. Calculating this value directly would involve a massive number, making it computationally infeasible.\nAlgorithm\r#\rThe method uses divide-and-conquer principles to reduce complexity from $O(e)$ to $O(\\log e)$.\nlong long modularExponentiation(long long base, long long exp, long long mod) { long long result = 1; while (exp \u0026gt; 0) { if (exp % 2 == 1) { result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } "},{"id":4,"href":"/journey-ds-algo/data-structures/segment-tree/","title":"Segment Tree","section":"Data Structures Problems","content":"\rSegment Tree\r#\rContent for Segment Tree problems goes here.\n"}]