[{"id":0,"href":"/math/arithmetic-counting-and-modulus/","title":"Arithmetic, counting and modulus operations","section":"Math Problems","content":"\rArithmetic, counting and modulus operations\r#\rIn this article, we aim to enhance our pattern recognition abilities by leveraging fundamental mathematical skills such as arithmetic, counting, and modulus operations.\nTo begin, we will explore a problem that encourages a deeper understanding of these techniques. This problem, known as Digit Queries, is part of the CSES problem set.\nDigit Queries - Problem statement\r#\rConsider an infinite string that consist of all positive integer in increasing order: 12345678910111213141516171819202122232425... Your task is to process $q$ queries of the form: what\u0026rsquo;s the digit at position $k$ in the string?\nConstraints\n$1 \\le q \\le 1000$ $1 \\le k \\le 10^{18}$ For example, if a query asks for the digit at position $k = 7$, we need to return 7. Why? Because the $7^{th}$ position in the infinite string 1234567... is indeed 7.\nAnother example: if $k = 12$, we must return 1 since the $12^{th}$ digit of the string 123456789101... is 1.\nAs a final example, consider $k = 19$. We need to return 4 because in the string 1234567891011121314..., the $19^{th}$ digit is 4.\nThoughts\r#\rThe string is infinite, so we cannot fully generate or store it. Instead, we need to identify patterns or make \u0026ldquo;jumps\u0026rdquo; through the sequence of digits.\nIf we consider the numbers grouped by their digit lengths:\n123456789 (1-digit numbers) 10111213141516171819202122...9899 (2-digit numbers) 100101102103104...998999 (3-digit numbers) ... and so forth For each digit length $d$, the total number of digits in that block can be expressed as:\n$$ block_d = 9 \\cdot 10^{d-1} \\cdot d $$\nFor example:\nIf $d = 1$, then $block_1 = 9 \\cdot 10^0 \\cdot 1 = 9$ digits. If $d = 2$, then $block_2 = 9 \\cdot 10^1 \\cdot 2 = 180$ digits. If $d = 3$, then $block_3 = 9 \\cdot 10^2 \\cdot 3 = 2700$ digits. Did you see the pattern?, its like we can build some solution that runs on $O(\\log_{10}(k))$.\nWe also know the starting point (the first number) for each block:\nIf $d = 1$, then $start = 1$ If $d = 2$, then $start = 10$ If $d = 3$, then $start = 100$ \u0026hellip; and so on.\nWith this information, we can find the specific number $num_k$ that contains the digit at position $k$:\n$$ num_k = start + \\frac{(k_{block_d} - 1)}{d} $$\nHere, $k_{block_d}$ is the position $k$ adjusted to the current digit block. We cannot use the raw $k^{th}$ position directly because we must first exclude all the digits from previous blocks.\nFor example, if $k = 19$, the first 9 digits are from the 1-digit block, leaving $k_{block_2} = 19 - 9 = 10$. Since the 2-digit block starts right after those 9 digits, we move forward within this block. We use $k_{block_2} - 1 = 9$ to determine how far into the 2-digit sequence we go, and in this case, $num_k = 14$.\nAfter finding $num_k$, we identify the exact digit with a modulus operation: $$ digitIndex = (k - 1) \\mod d $$\nWe then convert $num_k$ to a string and extract the character at digitIndex, num_k[digitIndex].\nCode\r#\r#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int q; cin \u0026gt;\u0026gt; q; while(q--){ ll k; cin \u0026gt;\u0026gt; k; ll d = 1; ll tot = 9 * d; ll ten = 1; while(tot \u0026lt; k){ k -= tot; d++; ten *= 10; tot = 9 * d * ten; } // numk = 99 -\u0026gt; d = 2 // nunk = 100 -\u0026gt; d = 3 // k \u0026gt;\u0026gt; iam here -\u0026gt; d // floor(k-1/d) ll numk = ten + (k-1)/d; ll i = (k-1)%d; string s = to_string(numk); //cout \u0026lt;\u0026lt; \u0026#34;k = \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34;, ten = \u0026#34; \u0026lt;\u0026lt; ten \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;numk = \u0026#34; \u0026lt;\u0026lt; numk \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s[i] \u0026lt;\u0026lt; endl; } return 0; } References\r#\rDigit Queries problem: https://cses.fi/problemset/task/2431/ "},{"id":1,"href":"/dynamic-programming-problems/dp-level-0/","title":"DP Level 0","section":"Dynamic Programming Problems","content":"\rDP Level 0\r#\rDynamic Programming (DP) problems generally involve the optimization of some discrete problem. This means that the solution typically revolves around breaking the problem into smaller subproblems, solving each of them, and combining the results to find the best possible answer.\nThe objective of this problem is to find the minimum cost while adhering to the given rules for valid passes.\n983. Minimum Cost For Tickets\r#\rLevel medium. Problem statement\r#\rYou have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in three different ways:\na 1-day pass is sold for costs[0] dollars, a 7-day pass is sold for costs[1] dollars, and a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel.\nFor example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days.\nExample 1:\r#\rInput: days = [1,4,6,7,8,20], costs = [2,7,15]\rOutput: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, \u0026hellip;, 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total, you spent $11 and covered all the days of your travel.`\nExample 2:\r#\rInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\rOutput: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, \u0026hellip;, 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total, you spent $17 and covered all the days of your travel.\nConstraints:\r#\r1 \u0026lt;= days.length \u0026lt;= 365 1 \u0026lt;= days[i] \u0026lt;= 365 costs.length == 3 1 \u0026lt;= costs[i] \u0026lt;= 1000 First Thoughts\r#\rThe first thing to consider is how to iterate over the vector\u0026lt;int\u0026gt; days. It must be sorted because we need to process some days before others. The second thing is that the problem gives us options. We have four choices: take a 1-day pass, a 7-day pass, a 30-day pass, or skip the current day if it’s not in the vector\u0026lt;int\u0026gt; days. The third thing is that we need to minimize a cost function using the information stored in vector\u0026lt;int\u0026gt; costs. With these characteristics, I can implement a solution using a recursive approach. Here’s the code:\nclass Solution { public: vector\u0026lt;bool\u0026gt; mustBuy; int n; int f(int d, vector\u0026lt;int\u0026gt;\u0026amp; days, vector\u0026lt;int\u0026gt;\u0026amp; costs){ if(d \u0026gt; days[n-1]) return 0; if(!mustBuy[d]){ return f(d+1, days, costs); } int best = INT_MAX; int op1 = costs[0] + f(d+1, days, costs); int op2 = costs[1] + f(d+7, days, costs); int op3 = costs[2] + f(d+30, days, costs); best = min(best, op1); best = min(best, op2); best = min(best, op3); return best; } int mincostTickets(vector\u0026lt;int\u0026gt;\u0026amp; days, vector\u0026lt;int\u0026gt;\u0026amp; costs) { mustBuy.resize(366,false); sort(days.begin(), days.end()); this-\u0026gt;n = days.size(); for(int d : days) mustBuy[d] = true; return f(days[0], days, costs); } }; Why use vector\u0026lt;bool\u0026gt; mustBuy? It’s a boolean vector that keeps track of whether a specific day needs to be processed or not. The code works, but the time complexity is terrible, around $O(3^n)$, where $n$ can be as large as 365. The first thing to notice is the structure of the problem/solution is consistent—it’s the same for each subproblem. To solve the problem for day d, I need to check if it’s a valid day in vector\u0026lt;int\u0026gt; days and calculate the three cost options. The second observation is that we always move forward because, in the future, I’ll have the complete solution. The base case exists in the future. For this reason: if(d \u0026gt; days[n-1]) return 0; With all this information, I can build the DP approach.\nDP approach\r#\rclass Solution { public: vector\u0026lt;bool\u0026gt; mustBuy; int n; int mincostTickets(vector\u0026lt;int\u0026gt;\u0026amp; days, vector\u0026lt;int\u0026gt;\u0026amp; costs) { mustBuy.resize(366,false); sort(days.begin(), days.end()); this-\u0026gt;n = days.size(); for(int d : days) mustBuy[d] = true; vector\u0026lt;int\u0026gt; dp(days[n-1]+31,INT_MAX); for(int base=days[n-1]+1; base\u0026lt; (days[n-1]+31); base++) dp[base] = 0; for(int d=days[n-1];d\u0026gt;=0;d--){ if(!mustBuy[d]){ dp[d] = dp[d+1]; }else{ dp[d] = min(dp[d], costs[0]+dp[d+1]); dp[d] = min(dp[d], costs[1]+dp[d+7]); dp[d] = min(dp[d], costs[2]+dp[d+30]); } } return dp[0]; } }; What’s my base case? I know that after the last day available, the contribution to my cost function is 0. So, all days beyond the last day must have a cost of 0. for(int base=days[n-1]+1; base\u0026lt; (days[n-1]+31); base++) dp[base] = 0; In this case, what\u0026rsquo;s my dp[d]? It\u0026rsquo;s defined as the minimum cost from day d to the last day available day[n-1]. $$ dp[d] = \\begin{cases} dp[d+1], \u0026amp; \\text{if } \\texttt{!mustBuy[d]} \\\\ \\min \\left ( \\begin{matrix} dp[d], \\\\ \\texttt{costs}_0 + dp[d+1], \\\\ \\texttt{costs}_1 + dp[d+7], \\\\ \\texttt{costs}_2 + dp[d+30] \\end{matrix} \\right), \u0026amp; \\text{otherwise} \\end{cases} $$ Conclusion\r#\rFinally, we can construct dp either from bottom-up or top-down. The main goal is to capture the patterns and relationships between the DP states. If you can create a recursive approach, you can transform it into an iterative approach by thinking in a DP manner. References\r#\rProblem: https://leetcode.com/problems/minimum-cost-for-tickets/description/?envType=daily-question\u0026envId=2024-12-31 "},{"id":2,"href":"/searching-and-sorting/easy-sort-problem/","title":"Easy Sort Problem","section":"Searching And Sorting Problems","content":"\rStarting with Sorting Problems\r#\rLet\u0026rsquo;s start by looking at this LeetCode problem to help you understand the core concepts. Together we\u0026rsquo;ll explore the different techniques and data structures you can use to solve it effectively.\n2593 - Find Score of An Array After Marking All Elements\r#\rLevel medium. Problem statement\r#\rYou are given an array nums consisting of positive integers.\nStarting with score = 0, apply the following algorithm:\nChoose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index. Add the value of the chosen integer to score. Mark the chosen element and its two adjacent elements if they exist. Repeat until all the array elements are marked. Return the score you get after applying the above algorithm.\nExample 1:\nInput: nums = [2,1,3,4,5,2] Output: 7 Explanation: We mark the elements as follows:\n1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2]. 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2]. 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2]. Our score is 1 + 2 + 4 = 7. Example 2: Input: nums = [2,3,5,1,3,2] Output: 5 Explanation: We mark the elements as follows:\n1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2]. 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2]. 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2]. Our score is 1 + 2 + 2 = 5. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 106\nThoughts\r#\rApproach 1\r#\rclass Solution { static class Pair implements Comparable\u0026lt;Pair\u0026gt;{ int num; int index; Pair(int num, int index){ this.num = num; this.index = index; } @Override public int compareTo(Pair other){ if(this.num != other.num){ return Integer.compare(this.num, other.num); } return Integer.compare(this.index, other.index); } } public long findScore(int[] nums) { long ans = 0; TreeSet\u0026lt;Pair\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); int n = nums.length; for(int i=0;i\u0026lt;n;i++){ set.add(new Pair(nums[i], i)); } while(!set.isEmpty()){ Pair p = set.pollFirst(); ans += (long) p.num; int idx = p.index; if(idx + 1 \u0026lt; n){ set.remove(new Pair(nums[idx+1],idx+1)); } if(idx - 1 \u0026gt;= 0){ set.remove(new Pair(nums[idx-1],idx-1)); } } return ans; } } Approach 2\r#\rclass Solution { public long findScore(int[] nums) { long ans = 0; int n = nums.length; int [][] sorted = new int[n][2]; boolean [] marked = new boolean[n]; for(int i=0;i\u0026lt;n;i++){ sorted[i][0] = nums[i]; sorted[i][1] = i; } Arrays.sort(sorted, (arr1, arr2) -\u0026gt; arr1[0] - arr2[0]); for(int i=0;i\u0026lt;n;i++){ int num = sorted[i][0]; int idx = sorted[i][1]; if(!marked[idx]){ ans += (long) num; marked[idx] = true; if(idx-1 \u0026gt;= 0){ marked[idx-1]=true; } if(idx+1 \u0026lt; n){ marked[idx+1]=true; } } } return ans; } } Submissions Results\r#\rReferences:\r#\rProblem: https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/description/ TreeSet data structure on java: https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html "},{"id":3,"href":"/strings/kmp/","title":"Knuth-Morris-Pratt","section":"Strings Problems","content":"\rDP Level 0\r#\rDynamic Programming (DP) problems generally involve the optimization of some discrete problem. This means that the solution typically revolves around breaking the problem into smaller subproblems, solving each of them, and combining the results to find the best possible answer.\nThe objective of this problem is to find the minimum cost while adhering to the given rules for valid passes.\n983. Minimum Cost For Tickets\r#\rLevel medium. Problem statement\r#\rYou have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in three different ways:\na 1-day pass is sold for costs[0] dollars, a 7-day pass is sold for costs[1] dollars, and a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel.\nFor example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days.\nExample 1:\r#\rInput: days = [1,4,6,7,8,20], costs = [2,7,15]\rOutput: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, \u0026hellip;, 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total, you spent $11 and covered all the days of your travel.`\nExample 2:\r#\rInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\rOutput: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, \u0026hellip;, 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total, you spent $17 and covered all the days of your travel.\nConstraints:\r#\r1 \u0026lt;= days.length \u0026lt;= 365 1 \u0026lt;= days[i] \u0026lt;= 365 costs.length == 3 1 \u0026lt;= costs[i] \u0026lt;= 1000 First Thoughts\r#\rThe first thing to consider is how to iterate over the vector\u0026lt;int\u0026gt; days. It must be sorted because we need to process some days before others. The second thing is that the problem gives us options. We have four choices: take a 1-day pass, a 7-day pass, a 30-day pass, or skip the current day if it’s not in the vector\u0026lt;int\u0026gt; days. The third thing is that we need to minimize a cost function using the information stored in vector\u0026lt;int\u0026gt; costs. With these characteristics, I can implement a solution using a recursive approach. Here’s the code:\nclass Solution { public: vector\u0026lt;bool\u0026gt; mustBuy; int n; int f(int d, vector\u0026lt;int\u0026gt;\u0026amp; days, vector\u0026lt;int\u0026gt;\u0026amp; costs){ if(d \u0026gt; days[n-1]) return 0; if(!mustBuy[d]){ return f(d+1, days, costs); } int best = INT_MAX; int op1 = costs[0] + f(d+1, days, costs); int op2 = costs[1] + f(d+7, days, costs); int op3 = costs[2] + f(d+30, days, costs); best = min(best, op1); best = min(best, op2); best = min(best, op3); return best; } int mincostTickets(vector\u0026lt;int\u0026gt;\u0026amp; days, vector\u0026lt;int\u0026gt;\u0026amp; costs) { mustBuy.resize(366,false); sort(days.begin(), days.end()); this-\u0026gt;n = days.size(); for(int d : days) mustBuy[d] = true; return f(days[0], days, costs); } }; Why use vector\u0026lt;bool\u0026gt; mustBuy? It’s a boolean vector that keeps track of whether a specific day needs to be processed or not. The code works, but the time complexity is terrible, around $O(3^n)$, where $n$ can be as large as 365. The first thing to notice is the structure of the problem/solution is consistent—it’s the same for each subproblem. To solve the problem for day d, I need to check if it’s a valid day in vector\u0026lt;int\u0026gt; days and calculate the three cost options. The second observation is that we always move forward because, in the future, I’ll have the complete solution. The base case exists in the future. For this reason: if(d \u0026gt; days[n-1]) return 0; With all this information, I can build the DP approach.\nDP approach\r#\rclass Solution { public: vector\u0026lt;bool\u0026gt; mustBuy; int n; int mincostTickets(vector\u0026lt;int\u0026gt;\u0026amp; days, vector\u0026lt;int\u0026gt;\u0026amp; costs) { mustBuy.resize(366,false); sort(days.begin(), days.end()); this-\u0026gt;n = days.size(); for(int d : days) mustBuy[d] = true; vector\u0026lt;int\u0026gt; dp(days[n-1]+31,INT_MAX); for(int base=days[n-1]+1; base\u0026lt; (days[n-1]+31); base++) dp[base] = 0; for(int d=days[n-1];d\u0026gt;=0;d--){ if(!mustBuy[d]){ dp[d] = dp[d+1]; }else{ dp[d] = min(dp[d], costs[0]+dp[d+1]); dp[d] = min(dp[d], costs[1]+dp[d+7]); dp[d] = min(dp[d], costs[2]+dp[d+30]); } } return dp[0]; } }; What’s my base case? I know that after the last day available, the contribution to my cost function is 0. So, all days beyond the last day must have a cost of 0. for(int base=days[n-1]+1; base\u0026lt; (days[n-1]+31); base++) dp[base] = 0; In this case, what\u0026rsquo;s my dp[d]? It\u0026rsquo;s defined as the minimum cost from day d to the last day available day[n-1]. $$ dp[d] = \\begin{cases} dp[d+1], \u0026amp; \\text{if } \\texttt{!mustBuy[d]} \\\\ \\min \\left ( \\begin{matrix} dp[d], \\\\ \\texttt{costs}_0 + dp[d+1], \\\\ \\texttt{costs}_1 + dp[d+7], \\\\ \\texttt{costs}_2 + dp[d+30] \\end{matrix} \\right), \u0026amp; \\text{otherwise} \\end{cases} $$ Conclusion\r#\rFinally, we can construct dp either from bottom-up or top-down. The main goal is to capture the patterns and relationships between the DP states. If you can create a recursive approach, you can transform it into an iterative approach by thinking in a DP manner. References\r#\rProblem: https://leetcode.com/problems/minimum-cost-for-tickets/description/?envType=daily-question\u0026envId=2024-12-31 "},{"id":4,"href":"/searching-and-sorting/","title":"Searching And Sorting Problems","section":"Home","content":"\rSearching and Sorting\r#\rTo understand this type of problem, we need to consider cases where a specific permutation of the array or vector might be beneficial for us. If such a permutation has the characteristic that its elements are ordered monotonically, we can implement a sorting algorithm to achieve this order.\nWhen it comes to the searching phase, it\u0026rsquo;s important to note that scanning an array of size n in the worst case takes $O(n)$ time. For large constraints, such as an array of size $10^9$, this becomes computationally infeasible, as scanning such an array empirically takes more than 1 second. Generally, if a solution takes too long to execute, it results in an error commonly known as TLE (Time Limit Exceeded).\nTable of Contents\r#\reasy sort problem "},{"id":5,"href":"/dynamic-programming-problems/dp-level-1/","title":"DP Level 1","section":"Dynamic Programming Problems","content":"\rDP Level 1\r#\rLet’s dive into this LeetCode problem to uncover the foundational concepts of dynamic programming. Together, we’ll explore the key techniques and data structures specific to DP that will help you approach and solve it effectively.\n2466. Count Ways To Build Good Strings\r#\rLevel medium. Problem statement\r#\rGiven the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:\nAppend the character \u0026lsquo;0\u0026rsquo; zero times. Append the character \u0026lsquo;1\u0026rsquo; one times. This can be performed any number of times.\nA good string is a string constructed by the above process having a length between low and high (inclusive).\nReturn the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo $10^9 + 7$.\nExample 1:\r#\rInput: low = 3, high = 3, zero = 1, one = 1\rOutput: 8 Explanation:\nOne possible valid good string is \u0026ldquo;011\u0026rdquo;. It can be constructed as follows: \u0026quot;\u0026quot; -\u0026gt; \u0026ldquo;0\u0026rdquo; -\u0026gt; \u0026ldquo;01\u0026rdquo; -\u0026gt; \u0026ldquo;011\u0026rdquo;. All binary strings from \u0026ldquo;000\u0026rdquo; to \u0026ldquo;111\u0026rdquo; are good strings in this example. Example 2:\r#\rInput: low = 2, high = 3, zero = 1, one = 2\rOutput: 5 Explanation:\nThe good strings are \u0026ldquo;00\u0026rdquo;, \u0026ldquo;11\u0026rdquo;, \u0026ldquo;000\u0026rdquo;, \u0026ldquo;110\u0026rdquo;, and \u0026ldquo;011\u0026rdquo;. Constraints:\r#\r$1 \\le low \\le high \\le 10^5$ $1 \\le zero, one \\le low$ First Thoughts\r#\rMy first approach was a recursive solution because, for me, it’s more intuitive to visualize the relationship and structure between the branches of each node. Here’s the code:\nclass Solution { public: int low, high, zero, one; int ans = 0; void f(int sz, string\u0026amp; s){ if(sz \u0026gt;= low \u0026amp;\u0026amp; sz \u0026lt;= high){ cout \u0026lt;\u0026lt;\u0026#34;permutation:\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; ans++; } if(sz \u0026gt; high){ return; } for(int k=1;k\u0026lt;=zero;k++) s.push_back(\u0026#39;0\u0026#39;); f(sz+zero, s); for(int k=1;k\u0026lt;=zero;k++) s.pop_back(); for(int k=1;k\u0026lt;=one;k++) s.push_back(\u0026#39;1\u0026#39;); f(sz+one, s); for(int k=1;k\u0026lt;=one;k++) s.pop_back(); } int countGoodStrings(int low, int high, int zero, int one) { this-\u0026gt;low = low; this-\u0026gt;high = high; this-\u0026gt;zero = zero; this-\u0026gt;one = one; string permutation = \u0026#34;\u0026#34;; f(0, permutation); return ans; } }; The code works, but the time complexity is terrible, around $O(2^n)$. Also, don’t forget that for each node, I add a char (either one or zero times) to a string for debugging purposes. The first thing to notice is that the structure of the solution is consistent (same), which is why I can use a f(sz) function. The second observation is that we always move forward because, in the future, I’ll have the complete solution. To create the new node or determine the next step of the algorithm, I only need to calculate or process the current state. The low and high variables act as constraints. The zero and one variables represent the steps or jumps needed to reach the next feasible node. With all this information, I can build the DP approach.\nDP approach\r#\rclass Solution { public: const int MOD = 1e9 + 7; int countGoodStrings(int low, int high, int zero, int one) { vector\u0026lt;long long\u0026gt; dp(high + max(one, zero) + 1, 0); for(int i=low; i\u0026lt;=high;i++){ dp[i] = 1; } for(int sz=high;sz\u0026gt;=0;sz--){ dp[sz] = dp[sz] % MOD + dp[sz+one] % MOD + dp[sz+zero] % MOD; dp[sz] %= MOD; } return dp[0]; } }; What’s my base case? I only have an answer if sz is between low and high inclusive. So, i record that information in my dp. If you look at my implementation, it uses the same order of processing as the previous recursive solution. I need all the paths where sz+one and sz+zero have answer $\u0026gt;0$. Therefore, dp[sz] is defined as the number of ways I can build a valid string with size sz. Conclusion\r#\rFinally, we can construct dp either from bottom-up or top-down. The main goal is to capture the patterns and relationships between the DP states. If you can create a recursive approach, you can transform it into an iterative approach by thinking in a DP manner. References\r#\rProblem: https://leetcode.com/problems/count-ways-to-build-good-strings/?envType=daily-question\u0026envId=2024-12-30 "},{"id":6,"href":"/dynamic-programming-problems/","title":"Dynamic Programming Problems","section":"Home","content":"\rDynamic Programming Problems\r#\rTo understand this type of problem, the first step is to identified the characteristics. For example:\nIt\u0026rsquo;s a maximum / minimum problem? (Optimal substructure) Do I need to count the number of ways for a specific events? (Combinatorics) Can this problem be solve using recursion? Does the problem follow the same properties or structure, independent of the problem\u0026rsquo;s size? (Overlapping subproblems) In your implementation on the recursive function, is there a specific order require to process the solution? Table of Contents\r#\rDP level 0 DP level 1 DP level 2 "},{"id":7,"href":"/math/legendres-formula/","title":"Legendre's Formula","section":"Math Problems","content":"\rLegendre\u0026rsquo;s Formula\r#\rWhy do we need to understand this technique?\nIn the CSES Problem Set, it is part of the introductory problems and serves as a foundational equation for building mathematical skills.\nProblem Statement:\r#\rThe original problem can be found here: CSES Problem 1618.\nThe task is to calculate the number of trailing zeros in the factorial $n!$. For example, $20! = 2432902008176640000$, which has 4 trailing zeros.\nIf we analyze the pattern, it looks like this:\n$$ \\begin{align*} 1! \u0026amp;= 1 \\\\ 2! \u0026amp;= 2 \\\\ 3! \u0026amp;= 6 \\\\ 4! \u0026amp;= 24 \\\\ 5! \u0026amp;= 120 \\\\ 6! \u0026amp;= 720 \\\\ 7! \u0026amp;= 5040 \\\\ 8! \u0026amp;= 40320 \\\\ 9! \u0026amp;= 362880 \\\\ 10! \u0026amp;= 3628800 \\\\ 11! \u0026amp;= 39916800 \\\\ 12! \u0026amp;= 479001600 \\\\ 13! \u0026amp;= 6227020800 \\\\ 14! \u0026amp;= 87178291200 \\\\ 15! \u0026amp;= 1307674368000 \\\\ 16! \u0026amp;= 20922789888000 \\end{align*} $$\nEvery multiple of 5 seems to add a trailing zero. But why does this happen?\nThis is because to add a zero to any number, we need $5 \\cdot 2 = 10$. Thus, every pair $(5, 2)$ contributes a trailing zero.\nFor instance:\n$$6! = 1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 \\cdot 6 = 2^4 \\cdot 3^2 \\cdot 5.$$\nFinally, to find the number of trailing zeros, we calculate: $$\\text{min}(x, y)$$ where:\n$x$ is the number of times (or the exponent) of the prime 2 is multiplied. (e.g., for 6, $x = 4$). $y$ is the number of times (or the exponent) of the prime 5 is multiplied. (e.g., for 6, $y = 1$). Thus, for $6$, $\\text{min}(x=4, y=1) = 1$, which is the trailing zero for this case.\nHere is where Legendre\u0026rsquo;s Formula comes in, as it provides an expression for the exponent of the largest power of a prime $p$ that divides the factorial $n!$:\n$$ v_p(n!) = \\sum_{i=1}^\\infty \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor $$\nWhere:\n$n$ is the factorial. $p$ is the prime. $\\lfloor x \\rfloor$ is the floor function. We can simplify the formula since if $p^i \u0026gt; n$, then $\\left\\lfloor \\frac{n}{p^i} \\right\\rfloor = 0$.\nThus: $$ v_p(n!) = \\sum_{i=1}^L \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor $$\nAnd: $$ L = \\lfloor \\log_p(n) \\rfloor $$\nIf we revisit $6!$, where $6! = 2^4 \\cdot 3^2 \\cdot 5$, we can calculate:\n$$ \\begin{align*} v_2(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_2(6) \\rfloor = 2} \\left\\lfloor \\frac{6}{2^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{2} \\right\\rfloor + \\left\\lfloor \\frac{6}{4} \\right\\rfloor = 3 + 1 = 4, \\\\ v_3(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_3(6) \\rfloor = 1} \\left\\lfloor \\frac{6}{3^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{3} \\right\\rfloor = 2, \\\\ v_5(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_5(6) \\rfloor = 1} \\left\\lfloor \\frac{6}{5^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{5} \\right\\rfloor = 1. \\end{align*} $$\nCode\r#\rThe time complexity is $O(\\log_p n)$, where $p$ is the prime, and the space complexity is $O(1)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; // Remember: for a \u0026#34;0\u0026#34; to exist, there must be a 10 or 2*5 primes // Legendre\u0026#39;s formula int cnt = 0; for(int i = 5; (n / i) \u0026gt; 0; i *= 5){ cnt += (n / i); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } References\r#\rhttps://en.wikipedia.org/wiki/Legendre%27s_formula "},{"id":8,"href":"/data-structures/","title":"Data Structures Problems","section":"Home","content":"\rData Structures Problems\r#\rTopics\r#\rDSU - Union and Find Segment Tree Graphs "},{"id":9,"href":"/dynamic-programming-problems/dp-level-2/","title":"DP Level 2","section":"Dynamic Programming Problems","content":"\rDP Level 2\r#\rReferences\r#\rhttps://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/description/ "},{"id":10,"href":"/math/modular-exponentiation/","title":"Modular Exponentiation","section":"Math Problems","content":"\rModular Exponentiation\r#\rImagine you need to compute a value $a^e$ where $a\u0026gt;0$ and $e$ is a large positive integer. Calculating this directly can result in excessively large numbers, leading to overflow errors. To avoid this, we use modular arithmetic, where the result is calculated modulo a given number $m$. In mathematical terms, we aim to compute:\n$$a^e \\mod m$$\nWhere:\n$a\u0026gt;0$ and $e\u0026gt;0$, both are integers. $m$ is the modulus, typically chosen to constrain the result within manageable bounds. Why Modular Exponentiation ?\r#\rFor example, $2^{1000}$. Calculating this value directly would involve a massive number, making it computationally infeasible due to both time complexity and memory constraints. Modular exponentiation is a technique designed to handle this efficiently.\nThe Logic behind\r#\rThe method relies on divide-and-conquer principles while leveraging properties of modular arithmetic to simplify intermediate results. This approach reduces the computational complexity from $O(e)$ to $O(\\log e )$, making it significantly faster.\nLet’s break it down using an example: compute $2^9 \\pmod{10^9 + 1}$.\nWe know:\n$$2^9 = 2\\cdot2^8 = 2\\cdot(2^4)^2$$\nThe idea is to take advantage of the parity (odd or even nature) of the exponent.\nif $e$ is odd, $a^e = a\\cdot a^{e-1}$. if $e$ is even, $a^e = (a^{e/2})^2$. This recursive pattern forms the basis of the iterative implementation of modular exponentiation.\nAlgorithm\r#\rlong long modularExponentiation(long long base, long long exp, long long mod) { long long result = 1; while (exp \u0026gt; 0) { if (exp % 2 == 1) { result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } Example Problems\r#\rhttps://cses.fi/problemset/task/1617/ We need use this technique, but it\u0026rsquo;s not the complete concept to understand the problem: https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-ii/description/ "},{"id":11,"href":"/strings/","title":"Strings Problems","section":"Home","content":"\rStrings Problems\r#\rTopics\r#\rPattern Matching - Knuth Morris Pratt - KMP Pattern Matching - Rabin Karp Pattern Matching - Z Algorithm "},{"id":12,"href":"/math/fermats-little-theorem/","title":"Fermat's little Theorem","section":"Math Problems","content":"\rFermat\u0026rsquo;s Little Theorem\r#\rIf $p$ is a prime number and $a$ is an integer such that $a$ is not divisible by $p$, then:\n$$a^{p-1} \\equiv 1 \\pmod{p}$$\nModular Inverse using Fermat\u0026rsquo;s Little Theorem\r#\rThe above theorem can be rearranged to give the modular inverse of $a$:\n$$a^{-1} \\equiv a^{p-2} \\pmod{p}$$\nThis allows us to calculate the inverse of $a$ under modulo $p$, which is useful for division in modular arithmetic. Example problem for use this technique: https://codeforces.com/contest/2008/problem/F\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; using pii = pair\u0026lt;int,int\u0026gt;; const int M = 1e9 + 7; // Modular inverse ll modularExponentiation(ll base, ll exp, ll mod){ ll result = 1; while(exp \u0026gt; 0){ if(exp % 2 == 1){ result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); ll S = 0; for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; a[i]; S = (S + a[i]) % M; } ll P = 0; for(int i=0;i\u0026lt;n;i++){ P = (P % M + (a[i] * (S - a[i] + M) ) % M ) % M; } P = ( P * mod_exp(2, M-2, M) ) % M; // P * 2^{-1} ll Q = (1LL * n * (n - 1) / 2) % M; ll Q_inv = mod_exp(Q, M-2, M); // Q^{-1} ll ans = (P * Q_inv) % M; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } "},{"id":13,"href":"/math/","title":"Math Problems","section":"Home","content":"\rMath Problems\r#\rTopics\r#\rArithmetic, counting and modulus operations Modular Exponentiation Fermat\u0026rsquo;s Little Theorem legendre\u0026rsquo;s Formula "},{"id":14,"href":"/data-structures/dequeue/","title":"Dequeue","section":"Data Structures Problems","content":"\rDequeue\r#\rWhat\u0026rsquo;s a dequeue?\r#\rIs a generalize version of a queue with double Ended, where we can insert and delete elements at boths sides.\nSo, in any problem when we need to pop or push elements fast on $O(1)$ this data structure is very util.\nProblem - find longest special substring that occurs thrice I\r#\rYou are given a string s that consists of lowercase English letters.\nA string is called special if its made up of only a single character. For example, the string abc is not special, whereas the string ddd, zz and f are special.\nReturn the length of the longest special substrings of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.\nA substrings is a contiguous non-empty sequence of characters within a string.\nExample test case 1:\r#\rInput: s = \u0026quot;aaaa\u0026quot; Output: 2\nExplanation:\nIf $k = 1$, so i have {{a}, {a}, {a}, {a}}, and repeat more than 3 times. Its a factible answer. If $k = 2$, so i have {{aa}, {aa}, {aa}}, and repeat more than 3 times. Its a factible answer and the best at moment. If $k = 3$, so i have {{aaa}, {aaa}}, and repeat more than 3 times. Its not a factible answer. Thoughts\r#\rThe substring must be contiguous and non-empty, so the combinations should consist of adjacent characters. If I need to calculate combinations of adjacent characters in a string, perhaps I can use a sliding window approach. However, with a sliding window, if I want to pop or push characters from the front or end of my temporary contiguous substrings of size k, the time complexity will increase if I try to insert elements at the front. Keep in mind that the += operation on a string creates a copy of the object, which uses both time and memory. To efficiently track the characters in my window, I can use a deque\u0026lt;char\u0026gt; for fast popping and pushing. References:\r#\rlink to the original problem: https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/description/ "},{"id":15,"href":"/data-structures/graphs/","title":"Graphs","section":"Data Structures Problems","content":"\rGraph Problems\r#\rContent for Graph Problems goes here.\n"},{"id":16,"href":"/data-structures/segment-tree/","title":"Segment Tree","section":"Data Structures Problems","content":"\rSegment Tree\r#\rContent for Segment Tree problems goes here.\n"}]