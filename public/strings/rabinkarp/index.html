<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  Rabin - Karp Algorithm
  #

The Rabin-Karp algorithm solves problems involving pattern matching within a string, where the complexity largely depends on the hash function used. This algorithm utilizes rolling hashing for string searching.
But what is rolling hashing?

  Rolling Hashing
  #

In simple terms, rolling hashing is a technique used to compute hash values efficiently for substrings of a string. It uses a sliding window approach, where the next window&rsquo;s hash is updated based on the previous window instead of being recomputed from scratch.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/strings/rabinkarp/">
  <meta property="og:site_name" content="A Journey Through DS and Algorithms">
  <meta property="og:title" content="Rabin - Karp algorithm">
  <meta property="og:description" content="Rabin - Karp Algorithm#The Rabin-Karp algorithm solves problems involving pattern matching within a string, where the complexity largely depends on the hash function used. This algorithm utilizes rolling hashing for string searching.
But what is rolling hashing?
Rolling Hashing#In simple terms, rolling hashing is a technique used to compute hash values efficiently for substrings of a string. It uses a sliding window approach, where the next windowâ€™s hash is updated based on the previous window instead of being recomputed from scratch.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="strings">
    <meta property="article:modified_time" content="2025-01-09T19:30:52-03:00">
<title>Rabin - Karp algorithm | A Journey Through DS and Algorithms</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/strings/rabinkarp/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.66040ba1eab73e280d73b78d62c1c8d5d10700d1b233a9acdbe3f6f9f2582d84.js" integrity="sha256-ZgQLoeq3PigNc7eNYsHI1dEHANGyM6ms2&#43;P2&#43;fJYLYQ=" crossorigin="anonymous"></script>

<link rel="stylesheet" href="/katex/katex.min.css">
<script defer src="/katex/katex.min.js"></script>
<script defer src="/katex/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>A Journey Through DS and Algorithms</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>













  



  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/searching-and-sorting/" class="">Searching And Sorting Problems</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/searching-and-sorting/easy-sort-problem/" class="">Easy Sort Problem</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/dynamic-programming-problems/" class="">Dynamic Programming Problems</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/dynamic-programming-problems/dp-level-0/" class="">DP Level 0</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/dynamic-programming-problems/dp-level-1/" class="">DP Level 1</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/dynamic-programming-problems/dp-level-2/" class="">DP Level 2</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/data-structures/" class="">Data Structures Problems</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/data-structures/dequeue/" class="">Dequeue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/data-structures/graphs/" class="">Graphs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/data-structures/segment-tree/" class="">Segment Tree</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/strings/" class="">Strings Problems</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/strings/rabinkarp/" class="active">Rabin - Karp algorithm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/strings/kmp/" class="">Knuth-Morris-Pratt</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/math/" class="">Math Problems</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/math/arithmetic-counting-and-modulus/" class="">Arithmetic, counting and modulus operations</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/math/legendres-formula/" class="">Legendre&#39;s Formula</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/math/modular-exponentiation/" class="">Modular Exponentiation</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/math/fermats-little-theorem/" class="">Fermat&#39;s little Theorem</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Rabin - Karp algorithm</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#rolling-hashing">Rolling Hashing</a></li>
    <li><a href="#key-idea-for-rabin-karp-double-hashing">Key idea for Rabin-Karp Double Hashing</a>
      <ul>
        <li><a href="#example-problem">Example Problem</a></li>
      </ul>
    </li>
    <li><a href="#code">Code</a>
      <ul>
        <li><a href="#analyzing-the-code">Analyzing the code</a></li>
        <li><a href="#references">References</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="rabin---karp-algorithm">
  Rabin - Karp Algorithm
  <a class="anchor" href="#rabin---karp-algorithm">#</a>
</h1>
<p>The Rabin-Karp algorithm solves problems involving pattern matching within a string, where the complexity largely depends on the hash function used. This algorithm utilizes <strong>rolling hashing</strong> for string searching.</p>
<p>But what is rolling hashing?</p>
<h2 id="rolling-hashing">
  Rolling Hashing
  <a class="anchor" href="#rolling-hashing">#</a>
</h2>
<p>In simple terms, rolling hashing is a technique used to compute hash values efficiently for substrings of a string. It uses a sliding window approach, where the next window&rsquo;s hash is updated based on the previous window instead of being recomputed from scratch.</p>
<p>Often, a single polynomial hash function is used, such as:
$$
H(s) = (c_0 \cdot p^{m-1} + c_1 \cdot p^{m-2} + &hellip; + c_{m-1}) \mod M
$$</p>
<p>Where:</p>
<ul>
<li>$m$ is the size of the substring.</li>
<li>$c_i$ is the character at position $i$.</li>
<li>$p$ is the base or radix number.</li>
<li>$M$ is the modulus.</li>
</ul>
<h2 id="key-idea-for-rabin-karp-double-hashing">
  Key idea for Rabin-Karp Double Hashing
  <a class="anchor" href="#key-idea-for-rabin-karp-double-hashing">#</a>
</h2>
<p>The Rabin-Karp algorithm uses the rolling hash technique with a <strong>double hashing</strong> approach. For each substring, the hash is computed as:</p>
<p>$$
Hash(s) = ( H_1(s), H_2(s) )
$$
Both hash functions should meet the following criteria:</p>
<ul>
<li>The modulus values of the two hash functions must be different $mod_1 \ne mod_2$.</li>
<li>The base or radix values $p$, must also differ $p_1 \ne p_2$.</li>
</ul>
<h3 id="example-problem">
  Example Problem
  <a class="anchor" href="#example-problem">#</a>
</h3>
<p>This is an <code>easy</code> problem of leetcode.</p>
<h4 id="28-find-the-index-of-the-first-occurrence-in-a-string">
  28. Find the Index of the First Occurrence in a String
  <a class="anchor" href="#28-find-the-index-of-the-first-occurrence-in-a-string">#</a>
</h4>
<p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>
<p>Example 1:</p>
<pre tabindex="0"><code>Input: haystack = &#34;sadbutsad&#34;, needle = &#34;sad&#34;
Output: 0
Explanation: &#34;sad&#34; occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.
</code></pre><p>Example 2:</p>
<pre tabindex="0"><code>Input: haystack = &#34;leetcode&#34;, needle = &#34;leeto&#34;
Output: -1
Explanation: &#34;leeto&#34; did not occur in &#34;leetcode&#34;, so we return -1.
</code></pre><p>Constraints:</p>
<pre tabindex="0"><code>1 &lt;= haystack.length, needle.length &lt;= 10^4
haystack and needle consist of only lowercase English characters.
</code></pre><h2 id="code">
  Code
  <a class="anchor" href="#code">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">typedef</span> <span style="color:#b00040">long</span> <span style="color:#b00040">long</span> ll;
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">class</span> <span style="color:#00f;font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000;font-weight:bold">const</span> ll MOD1 <span style="color:#666">=</span> <span style="color:#666">1e9</span> <span style="color:#666">+</span> <span style="color:#666">7</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#008000;font-weight:bold">const</span> ll RADIX1 <span style="color:#666">=</span> <span style="color:#666">26</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#008000;font-weight:bold">const</span> ll MOD2 <span style="color:#666">=</span> <span style="color:#666">1e9</span> <span style="color:#666">+</span> <span style="color:#666">33</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#008000;font-weight:bold">const</span> ll RADIX2 <span style="color:#666">=</span> <span style="color:#666">27</span>;
</span></span><span style="display:flex;"><span>    pair<span style="color:#666">&lt;</span>ll,ll<span style="color:#666">&gt;</span> hashMe(string <span style="color:#666">&amp;</span> s, <span style="color:#b00040">int</span> m){
</span></span><span style="display:flex;"><span>        ll factor1 <span style="color:#666">=</span> <span style="color:#666">1</span>, factor2 <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        pair<span style="color:#666">&lt;</span>ll, ll<span style="color:#666">&gt;</span> ans <span style="color:#666">=</span> {<span style="color:#666">0</span>, <span style="color:#666">0</span>};
</span></span><span style="display:flex;"><span>        <span style="color:#008000;font-weight:bold">for</span>(<span style="color:#b00040">int</span> i<span style="color:#666">=</span>m<span style="color:#666">-</span><span style="color:#666">1</span>;i<span style="color:#666">&gt;=</span><span style="color:#666">0</span>;i<span style="color:#666">--</span>){
</span></span><span style="display:flex;"><span>            ans.first <span style="color:#666">+=</span> ((s[i]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>) <span style="color:#666">*</span> factor1) <span style="color:#666">%</span> MOD1;
</span></span><span style="display:flex;"><span>            factor1 <span style="color:#666">=</span> (factor1 <span style="color:#666">*</span> RADIX1) <span style="color:#666">%</span> MOD1;
</span></span><span style="display:flex;"><span>            ans.second <span style="color:#666">+=</span> ((s[i]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>) <span style="color:#666">*</span> factor2) <span style="color:#666">%</span> MOD2;
</span></span><span style="display:flex;"><span>            factor2 <span style="color:#666">=</span> (factor2 <span style="color:#666">*</span> RADIX2) <span style="color:#666">%</span> MOD2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ans.first <span style="color:#666">%=</span> MOD1;
</span></span><span style="display:flex;"><span>        ans.second <span style="color:#666">%=</span> MOD2;
</span></span><span style="display:flex;"><span>        <span style="color:#008000;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#b00040">int</span> <span style="color:#00f">strStr</span>(string haystack, string needle) {
</span></span><span style="display:flex;"><span>        <span style="color:#b00040">int</span> m <span style="color:#666">=</span> needle.length();
</span></span><span style="display:flex;"><span>        <span style="color:#b00040">int</span> n <span style="color:#666">=</span> haystack.length();
</span></span><span style="display:flex;"><span>        <span style="color:#008000;font-weight:bold">if</span>(n <span style="color:#666">&lt;</span> m) <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ll MAX_WEIGHT1 <span style="color:#666">=</span> <span style="color:#666">1</span>, MAX_WEIGHT2 <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#008000;font-weight:bold">for</span>(<span style="color:#b00040">int</span> i<span style="color:#666">=</span><span style="color:#666">0</span>;i<span style="color:#666">&lt;</span>m;i<span style="color:#666">++</span>){
</span></span><span style="display:flex;"><span>            MAX_WEIGHT1 <span style="color:#666">=</span> (MAX_WEIGHT1 <span style="color:#666">*</span> RADIX1) <span style="color:#666">%</span> MOD1;
</span></span><span style="display:flex;"><span>            MAX_WEIGHT2 <span style="color:#666">=</span> (MAX_WEIGHT2 <span style="color:#666">*</span> RADIX2) <span style="color:#666">%</span> MOD2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pair<span style="color:#666">&lt;</span>ll,ll<span style="color:#666">&gt;</span> hashNeedle <span style="color:#666">=</span> hashMe(needle, m);
</span></span><span style="display:flex;"><span>        pair<span style="color:#666">&lt;</span>ll, ll<span style="color:#666">&gt;</span> hashHay;
</span></span><span style="display:flex;"><span>        <span style="color:#008000;font-weight:bold">for</span>(<span style="color:#b00040">int</span> i<span style="color:#666">=</span><span style="color:#666">0</span>;i <span style="color:#666">&lt;=</span>(n<span style="color:#666">-</span>m);i<span style="color:#666">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#008000;font-weight:bold">if</span>(i <span style="color:#666">==</span> <span style="color:#666">0</span>){
</span></span><span style="display:flex;"><span>                hashHay <span style="color:#666">=</span> hashMe(haystack, m);
</span></span><span style="display:flex;"><span>            }<span style="color:#008000;font-weight:bold">else</span>{
</span></span><span style="display:flex;"><span>                hashHay.first <span style="color:#666">=</span> ((hashHay.first <span style="color:#666">*</span> RADIX1)<span style="color:#666">%</span>MOD1 <span style="color:#666">-</span> ((haystack[i<span style="color:#666">-</span><span style="color:#666">1</span>]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>)<span style="color:#666">*</span>MAX_WEIGHT1)<span style="color:#666">%</span>MOD1 <span style="color:#666">+</span> (haystack[i<span style="color:#666">+</span>m<span style="color:#666">-</span><span style="color:#666">1</span>]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>) <span style="color:#666">+</span> MOD1) <span style="color:#666">%</span> MOD1;
</span></span><span style="display:flex;"><span>                hashHay.second <span style="color:#666">=</span> ((hashHay.second <span style="color:#666">*</span> RADIX2)<span style="color:#666">%</span>MOD2 <span style="color:#666">-</span> ((haystack[i<span style="color:#666">-</span><span style="color:#666">1</span>]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>)<span style="color:#666">*</span>MAX_WEIGHT2)<span style="color:#666">%</span>MOD2 <span style="color:#666">+</span> (haystack[i<span style="color:#666">+</span>m<span style="color:#666">-</span><span style="color:#666">1</span>]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>) <span style="color:#666">+</span> MOD2) <span style="color:#666">%</span> MOD2;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#008000;font-weight:bold">if</span>(hashNeedle.first <span style="color:#666">==</span> hashHay.first <span style="color:#666">&amp;&amp;</span> hashNeedle.second <span style="color:#666">==</span> hashHay.second){
</span></span><span style="display:flex;"><span>                <span style="color:#008000;font-weight:bold">return</span> i;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="analyzing-the-code">
  Analyzing the code
  <a class="anchor" href="#analyzing-the-code">#</a>
</h3>
<h4 id="constants">
  Constants
  <a class="anchor" href="#constants">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">const</span> ll MOD1 <span style="color:#666">=</span> <span style="color:#666">1e9</span> <span style="color:#666">+</span> <span style="color:#666">7</span>;
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">const</span> ll RADIX1 <span style="color:#666">=</span> <span style="color:#666">26</span>;
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">const</span> ll MOD2 <span style="color:#666">=</span> <span style="color:#666">1e9</span> <span style="color:#666">+</span> <span style="color:#666">33</span>;
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">const</span> ll RADIX2 <span style="color:#666">=</span> <span style="color:#666">27</span>;
</span></span></code></pre></div><ul>
<li>This variables are <code>constant</code> and type <code>long long</code>, that represent the modulus $mod_i$ and base $p_i$ to each hash function $H_i(s)$.</li>
</ul>
<h4 id="hash-function">
  Hash Function
  <a class="anchor" href="#hash-function">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>pair<span style="color:#666">&lt;</span>ll,ll<span style="color:#666">&gt;</span> hashMe(string <span style="color:#666">&amp;</span> s, <span style="color:#b00040">int</span> m){
</span></span><span style="display:flex;"><span>    ll factor1 <span style="color:#666">=</span> <span style="color:#666">1</span>, factor2 <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    pair<span style="color:#666">&lt;</span>ll, ll<span style="color:#666">&gt;</span> ans <span style="color:#666">=</span> {<span style="color:#666">0</span>, <span style="color:#666">0</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#008000;font-weight:bold">for</span>(<span style="color:#b00040">int</span> i<span style="color:#666">=</span>m<span style="color:#666">-</span><span style="color:#666">1</span>;i<span style="color:#666">&gt;=</span><span style="color:#666">0</span>;i<span style="color:#666">--</span>){
</span></span><span style="display:flex;"><span>        ans.first <span style="color:#666">+=</span> ((s[i]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>) <span style="color:#666">*</span> factor1) <span style="color:#666">%</span> MOD1;
</span></span><span style="display:flex;"><span>        factor1 <span style="color:#666">=</span> (factor1 <span style="color:#666">*</span> RADIX1) <span style="color:#666">%</span> MOD1;
</span></span><span style="display:flex;"><span>        ans.second <span style="color:#666">+=</span> ((s[i]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>) <span style="color:#666">*</span> factor2) <span style="color:#666">%</span> MOD2;
</span></span><span style="display:flex;"><span>        factor2 <span style="color:#666">=</span> (factor2 <span style="color:#666">*</span> RADIX2) <span style="color:#666">%</span> MOD2;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ans.first <span style="color:#666">%=</span> MOD1;
</span></span><span style="display:flex;"><span>    ans.second <span style="color:#666">%=</span> MOD2;
</span></span><span style="display:flex;"><span>    <span style="color:#008000;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>This function call <code>hashMe</code> gonna give us a pair of type <code>long long</code>.</li>
<li>This function computes the hash values for a string <code>s</code> and returns a pair of hashes.</li>
<li>So if you see, we declare two variables <code>factor</code> both gonna storage the <code>RADIX</code> or base value that multiply <code>m</code> times for each <code>hash</code>.</li>
<li>The <code>pair&lt;ll,ll&gt; ans</code> is the answer of the first and second hash value.</li>
</ul>
<h4 id="rolling-hashing-construction">
  Rolling Hashing construction
  <a class="anchor" href="#rolling-hashing-construction">#</a>
</h4>
<p>Within the loop:</p>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">for</span>(<span style="color:#b00040">int</span> i<span style="color:#666">=</span>m<span style="color:#666">-</span><span style="color:#666">1</span>;i<span style="color:#666">&gt;=</span><span style="color:#666">0</span>;i<span style="color:#666">--</span>){
</span></span><span style="display:flex;"><span>    ans.first <span style="color:#666">+=</span> ((s[i]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>) <span style="color:#666">*</span> factor1) <span style="color:#666">%</span> MOD1; <span style="color:#408080;font-style:italic">// multiply with the char, the minus &#39;a&#39; is for get the number from ascii value
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>    factor1 <span style="color:#666">=</span> (factor1 <span style="color:#666">*</span> RADIX1) <span style="color:#666">%</span> MOD1; <span style="color:#408080;font-style:italic">// accumulate the RADIX
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>ans.first <span style="color:#666">%=</span> MOD1;
</span></span></code></pre></div><ul>
<li>The first thing is we gonna iterate the <code>string</code> in reverse with a size of <code>m</code> steps.</li>
<li>So, the first value must be <code>s[m-1]-'a' * factor1</code>, where <code>factor1</code> is <code>1</code>.
<ul>
<li>The next, <code>s[m-2] * factor1</code>, where <code>factor1 = 26</code>.</li>
<li>The next iteration <code>s[m-3] * factor1</code> where <code>factor1 = 26 * 26</code>.</li>
<li>And so on.
In simple terms, we construct this:
$$
H(s) = (c_0 \cdot p^{m-1} + c_1 \cdot p^{m-2} + &hellip; + c_{m-1}) \mod M
$$</li>
</ul>
</li>
</ul>
<h4 id="preprocess-purpose-and-sliding-window-approach">
  Preprocess purpose and Sliding Window approach
  <a class="anchor" href="#preprocess-purpose-and-sliding-window-approach">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ll MAX_WEIGHT1 <span style="color:#666">=</span> <span style="color:#666">1</span>, MAX_WEIGHT2 <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">for</span>(<span style="color:#b00040">int</span> i<span style="color:#666">=</span><span style="color:#666">0</span>;i<span style="color:#666">&lt;</span>m;i<span style="color:#666">++</span>){
</span></span><span style="display:flex;"><span>    MAX_WEIGHT1 <span style="color:#666">=</span> (MAX_WEIGHT1 <span style="color:#666">*</span> RADIX1) <span style="color:#666">%</span> MOD1;
</span></span><span style="display:flex;"><span>    MAX_WEIGHT2 <span style="color:#666">=</span> (MAX_WEIGHT2 <span style="color:#666">*</span> RADIX2) <span style="color:#666">%</span> MOD2;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>This is for precalculating the radix $high$ degree value used in the sliding window approach, where:
$$
H_i(s) = H_i(s) \cdot \text{RADIX} - c_{i-1} \cdot \text{RADIX-High-degree} + c_{i + m - 1}
$$</li>
<li>We perform this operation in constant time. The same technique is described in the book Introduction to Algorithms by MIT (where the radix value is <code>10</code>):</li>
</ul>
<p><img src="/images/rabinKarpCite.PNG" alt="Alt text" />
<strong>Figure 1</strong>: <em>Introduction to Algorithms</em>, MIT, p. 991.</p>
<ul>
<li>Finally, with the previous method, we perform $O(n - m)$ iterations, where $n$ is the size of thee <code>text</code> and $m$ is the size of the <code>pattern</code>.</li>
</ul>
<h4 id="why-introduce-the-modulus">
  Why introduce the modulus?
  <a class="anchor" href="#why-introduce-the-modulus">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>hashHay.first <span style="color:#666">=</span> ((hashHay.first <span style="color:#666">*</span> RADIX1)<span style="color:#666">%</span>MOD1 <span style="color:#666">-</span> ((haystack[i<span style="color:#666">-</span><span style="color:#666">1</span>]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>)<span style="color:#666">*</span>MAX_WEIGHT1)<span style="color:#666">%</span>MOD1 <span style="color:#666">+</span> (haystack[i<span style="color:#666">+</span>m<span style="color:#666">-</span><span style="color:#666">1</span>]<span style="color:#666">-</span><span style="color:#ba2121">&#39;a&#39;</span>) <span style="color:#666">+</span> MOD1) <span style="color:#666">%</span> MOD1;
</span></span></code></pre></div><p>Because the <code>hash</code> value can become very large, for example, in this problem, the radix value is <code>26</code> and if the size of the pattern is <code>100</code>, the maximum radix or high-degree radix would be, following our example, $26^{100}$. For that reason, we need to modularize to avoid bounds problems.
However, introducing a modulus increases the chances of collisions, also known as <code>spurious hit</code>.</p>
<h4 id="how-can-we-solve-the-spurious-hit-problem">
  How can we solve the spurious hit problem?
  <a class="anchor" href="#how-can-we-solve-the-spurious-hit-problem">#</a>
</h4>
<p>We can use <strong>double hashing</strong>. This method significantly reduces the probability of collisions because a value would need to produce the same hash from both hash functions, which is highly unlikely.</p>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">if</span>(hashNeedle.first <span style="color:#666">==</span> hashHay.first <span style="color:#666">&amp;&amp;</span> hashNeedle.second <span style="color:#666">==</span> hashHay.second){
</span></span><span style="display:flex;"><span>    <span style="color:#008000;font-weight:bold">return</span> i;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="references">
  References
  <a class="anchor" href="#references">#</a>
</h3>
<ul>
<li>Problem: <a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/</a></li>
<li>Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms. 3rd ed. Cambridge: MIT Press, 2009. Chapter 32, String Matching. Available at <a href="https://edutechlearners.com/download/Introduction_to_algorithms-3rd%20Edition.pdf">https://edutechlearners.com/download/Introduction_to_algorithms-3rd%20Edition.pdf</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm">https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm</a></li>
<li><a href="https://www.youtube.com/watch?v=io9yJ-KelgE&amp;ab_channel=AryanMittal">https://www.youtube.com/watch?v=io9yJ-KelgE&ab_channel=AryanMittal</a></li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#rolling-hashing">Rolling Hashing</a></li>
    <li><a href="#key-idea-for-rabin-karp-double-hashing">Key idea for Rabin-Karp Double Hashing</a>
      <ul>
        <li><a href="#example-problem">Example Problem</a></li>
      </ul>
    </li>
    <li><a href="#code">Code</a>
      <ul>
        <li><a href="#analyzing-the-code">Analyzing the code</a></li>
        <li><a href="#references">References</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












