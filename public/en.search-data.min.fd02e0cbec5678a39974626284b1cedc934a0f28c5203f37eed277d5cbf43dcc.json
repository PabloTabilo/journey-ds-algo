[{"id":0,"href":"/math/arithmetic-counting-and-modulus/","title":"Arithmetic, counting and modulus operations","section":"Math Problems","content":"\rArithmetic, counting and modulus operations\r#\rIn this article, we aim to enhance our pattern recognition abilities by leveraging fundamental mathematical skills such as arithmetic, counting, and modulus operations.\nTo begin, we will explore a problem that encourages a deeper understanding of these techniques. This problem, known as Digit Queries, is part of the CSES problem set.\nDigit Queries - Problem statement\r#\rConsider an infinite string that consist of all positive integer in increasing order: 12345678910111213141516171819202122232425... Your task is to process $q$ queries of the form: what\u0026rsquo;s the digit at position $k$ in the string?\nConstraints\n$1 \\le q \\le 1000$ $1 \\le k \\le 10^{18}$ For example, if a query asks for the digit at position $k = 7$, we need to return 7. Why? Because the $7^{th}$ position in the infinite string 1234567... is indeed 7.\nAnother example: if $k = 12$, we must return 1 since the $12^{th}$ digit of the string 123456789101... is 1.\nAs a final example, consider $k = 19$. We need to return 4 because in the string 1234567891011121314..., the $19^{th}$ digit is 4.\nThoughts\r#\rThe string is infinite, so we cannot fully generate or store it. Instead, we need to identify patterns or make \u0026ldquo;jumps\u0026rdquo; through the sequence of digits.\nIf we consider the numbers grouped by their digit lengths:\n123456789 (1-digit numbers) 10111213141516171819202122...9899 (2-digit numbers) 100101102103104...998999 (3-digit numbers) ... and so forth For each digit length $d$, the total number of digits in that block can be expressed as:\n$$ block_d = 9 \\cdot 10^{d-1} \\cdot d $$\nFor example:\nIf $d = 1$, then $block_1 = 9 \\cdot 10^0 \\cdot 1 = 9$ digits. If $d = 2$, then $block_2 = 9 \\cdot 10^1 \\cdot 2 = 180$ digits. If $d = 3$, then $block_3 = 9 \\cdot 10^2 \\cdot 3 = 2700$ digits. Did you see the pattern?, its like we can build some solution that runs on $O(\\log_{10}(k))$.\nWe also know the starting point (the first number) for each block:\nIf $d = 1$, then $start = 1$ If $d = 2$, then $start = 10$ If $d = 3$, then $start = 100$ \u0026hellip; and so on.\nWith this information, we can find the specific number $num_k$ that contains the digit at position $k$:\n$$ num_k = start + \\frac{(k_{block_d} - 1)}{d} $$\nHere, $k_{block_d}$ is the position $k$ adjusted to the current digit block. We cannot use the raw $k^{th}$ position directly because we must first exclude all the digits from previous blocks.\nFor example, if $k = 19$, the first 9 digits are from the 1-digit block, leaving $k_{block_2} = 19 - 9 = 10$. Since the 2-digit block starts right after those 9 digits, we move forward within this block. We use $k_{block_2} - 1 = 9$ to determine how far into the 2-digit sequence we go, and in this case, $num_k = 14$.\nAfter finding $num_k$, we identify the exact digit with a modulus operation: $$ digitIndex = (k - 1) \\mod d $$\nWe then convert $num_k$ to a string and extract the character at digitIndex, num_k[digitIndex].\nCode\r#\r#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int q; cin \u0026gt;\u0026gt; q; while(q--){ ll k; cin \u0026gt;\u0026gt; k; ll d = 1; ll tot = 9 * d; ll ten = 1; while(tot \u0026lt; k){ k -= tot; d++; ten *= 10; tot = 9 * d * ten; } // numk = 99 -\u0026gt; d = 2 // nunk = 100 -\u0026gt; d = 3 // k \u0026gt;\u0026gt; iam here -\u0026gt; d // floor(k-1/d) ll numk = ten + (k-1)/d; ll i = (k-1)%d; string s = to_string(numk); //cout \u0026lt;\u0026lt; \u0026#34;k = \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34;, ten = \u0026#34; \u0026lt;\u0026lt; ten \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;numk = \u0026#34; \u0026lt;\u0026lt; numk \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s[i] \u0026lt;\u0026lt; endl; } return 0; } References\r#\rDigit Queries problem: https://cses.fi/problemset/task/2431/ "},{"id":1,"href":"/math/","title":"Math Problems","section":"Home","content":"\rMath Problems\r#\rTopics\r#\rArithmetic, counting and modulus operations Modular Exponentiation Fermat\u0026rsquo;s Little Theorem legendre\u0026rsquo;s Formula "},{"id":2,"href":"/data-structures/","title":"Data Structures Problems","section":"Home","content":"\rData Structures Problems\r#\rTopics\r#\rDSU - Union and Find Segment Tree Graphs "},{"id":3,"href":"/math/legendres-formula/","title":"Legendre's Formula","section":"Math Problems","content":"\rLegendre\u0026rsquo;s Formula\r#\rWhy do we need to understand this technique?\nIn the CSES Problem Set, it is part of the introductory problems and serves as a foundational equation for building mathematical skills.\nProblem Statement:\r#\rThe original problem can be found here: CSES Problem 1618.\nThe task is to calculate the number of trailing zeros in the factorial $n!$. For example, $20! = 2432902008176640000$, which has 4 trailing zeros.\nIf we analyze the pattern, it looks like this:\n$$ \\begin{align*} 1! \u0026amp;= 1 \\\\ 2! \u0026amp;= 2 \\\\ 3! \u0026amp;= 6 \\\\ 4! \u0026amp;= 24 \\\\ 5! \u0026amp;= 120 \\\\ 6! \u0026amp;= 720 \\\\ 7! \u0026amp;= 5040 \\\\ 8! \u0026amp;= 40320 \\\\ 9! \u0026amp;= 362880 \\\\ 10! \u0026amp;= 3628800 \\\\ 11! \u0026amp;= 39916800 \\\\ 12! \u0026amp;= 479001600 \\\\ 13! \u0026amp;= 6227020800 \\\\ 14! \u0026amp;= 87178291200 \\\\ 15! \u0026amp;= 1307674368000 \\\\ 16! \u0026amp;= 20922789888000 \\end{align*} $$\nEvery multiple of 5 seems to add a trailing zero. But why does this happen?\nThis is because to add a zero to any number, we need $5 \\cdot 2 = 10$. Thus, every pair $(5, 2)$ contributes a trailing zero.\nFor instance:\n$$6! = 1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 \\cdot 6 = 2^4 \\cdot 3^2 \\cdot 5.$$\nFinally, to find the number of trailing zeros, we calculate: $$\\text{min}(x, y)$$ where:\n$x$ is the number of times (or the exponent) of the prime 2 is multiplied. (e.g., for 6, $x = 4$). $y$ is the number of times (or the exponent) of the prime 5 is multiplied. (e.g., for 6, $y = 1$). Thus, for $6$, $\\text{min}(x=4, y=1) = 1$, which is the trailing zero for this case.\nHere is where Legendre\u0026rsquo;s Formula comes in, as it provides an expression for the exponent of the largest power of a prime $p$ that divides the factorial $n!$:\n$$ v_p(n!) = \\sum_{i=1}^\\infty \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor $$\nWhere:\n$n$ is the factorial. $p$ is the prime. $\\lfloor x \\rfloor$ is the floor function. We can simplify the formula since if $p^i \u0026gt; n$, then $\\left\\lfloor \\frac{n}{p^i} \\right\\rfloor = 0$.\nThus: $$ v_p(n!) = \\sum_{i=1}^L \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor $$\nAnd: $$ L = \\lfloor \\log_p(n) \\rfloor $$\nIf we revisit $6!$, where $6! = 2^4 \\cdot 3^2 \\cdot 5$, we can calculate:\n$$ \\begin{align*} v_2(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_2(6) \\rfloor = 2} \\left\\lfloor \\frac{6}{2^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{2} \\right\\rfloor + \\left\\lfloor \\frac{6}{4} \\right\\rfloor = 3 + 1 = 4, \\\\ v_3(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_3(6) \\rfloor = 1} \\left\\lfloor \\frac{6}{3^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{3} \\right\\rfloor = 2, \\\\ v_5(6!) \u0026amp;= \\sum_{i=1}^{L = \\lfloor \\log_5(6) \\rfloor = 1} \\left\\lfloor \\frac{6}{5^i} \\right\\rfloor = \\left\\lfloor \\frac{6}{5} \\right\\rfloor = 1. \\end{align*} $$\nCode\r#\rThe time complexity is $O(\\log_p n)$, where $p$ is the prime, and the space complexity is $O(1)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; // Remember: for a \u0026#34;0\u0026#34; to exist, there must be a 10 or 2*5 primes // Legendre\u0026#39;s formula int cnt = 0; for(int i = 5; (n / i) \u0026gt; 0; i *= 5){ cnt += (n / i); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } References\r#\rhttps://en.wikipedia.org/wiki/Legendre%27s_formula "},{"id":4,"href":"/math/modular-exponentiation/","title":"Modular Exponentiation","section":"Math Problems","content":"\rModular Exponentiation\r#\rImagine you need to compute a value $a^e$ where $a\u0026gt;0$ and $e$ is a large positive integer. Calculating this directly can result in excessively large numbers, leading to overflow errors. To avoid this, we use modular arithmetic, where the result is calculated modulo a given number $m$. In mathematical terms, we aim to compute:\n$$a^e \\mod m$$\nWhere:\n$a\u0026gt;0$ and $e\u0026gt;0$, both are integers. $m$ is the modulus, typically chosen to constrain the result within manageable bounds. Why Modular Exponentiation ?\r#\rFor example, $2^{1000}$. Calculating this value directly would involve a massive number, making it computationally infeasible due to both time complexity and memory constraints. Modular exponentiation is a technique designed to handle this efficiently.\nThe Logic behind\r#\rThe method relies on divide-and-conquer principles while leveraging properties of modular arithmetic to simplify intermediate results. This approach reduces the computational complexity from $O(e)$ to $O(\\log e )$, making it significantly faster.\nLetâ€™s break it down using an example: compute $2^9 \\pmod{10^9 + 1}$.\nWe know:\n$$2^9 = 2\\cdot2^8 = 2\\cdot(2^4)^2$$\nThe idea is to take advantage of the parity (odd or even nature) of the exponent.\nif $e$ is odd, $a^e = a\\cdot a^{e-1}$. if $e$ is even, $a^e = (a^{e/2})^2$. This recursive pattern forms the basis of the iterative implementation of modular exponentiation.\nAlgorithm\r#\rlong long modularExponentiation(long long base, long long exp, long long mod) { long long result = 1; while (exp \u0026gt; 0) { if (exp % 2 == 1) { result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } Example Problems\r#\rhttps://cses.fi/problemset/task/1617/ We need use this technique, but it\u0026rsquo;s not the complete concept to understand the problem: https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-ii/description/ "},{"id":5,"href":"/math/fermats-little-theorem/","title":"Fermat's little Theorem","section":"Math Problems","content":"\rFermat\u0026rsquo;s Little Theorem\r#\rIf $p$ is a prime number and $a$ is an integer such that $a$ is not divisible by $p$, then:\n$$a^{p-1} \\equiv 1 \\pmod{p}$$\nModular Inverse using Fermat\u0026rsquo;s Little Theorem\r#\rThe above theorem can be rearranged to give the modular inverse of $a$:\n$$a^{-1} \\equiv a^{p-2} \\pmod{p}$$\nThis allows us to calculate the inverse of $a$ under modulo $p$, which is useful for division in modular arithmetic. Example problem for use this technique: https://codeforces.com/contest/2008/problem/F\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; using pii = pair\u0026lt;int,int\u0026gt;; const int M = 1e9 + 7; // Modular inverse ll modularExponentiation(ll base, ll exp, ll mod){ ll result = 1; while(exp \u0026gt; 0){ if(exp % 2 == 1){ result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result; } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); ll S = 0; for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; a[i]; S = (S + a[i]) % M; } ll P = 0; for(int i=0;i\u0026lt;n;i++){ P = (P % M + (a[i] * (S - a[i] + M) ) % M ) % M; } P = ( P * mod_exp(2, M-2, M) ) % M; // P * 2^{-1} ll Q = (1LL * n * (n - 1) / 2) % M; ll Q_inv = mod_exp(Q, M-2, M); // Q^{-1} ll ans = (P * Q_inv) % M; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } "},{"id":6,"href":"/data-structures/dequeue/","title":"Dequeue","section":"Data Structures Problems","content":"\rDequeue\r#\rWhat\u0026rsquo;s a dequeue?\r#\rIs a generalize version of a queue with double Ended, where we can insert and delete elements at boths sides.\nSo, in any problem when we need to pop or push elements fast on $O(1)$ this data structure is very util.\nProblem - find longest special substring that occurs thrice I\r#\rYou are given a string s that consists of lowercase English letters.\nA string is called special if its made up of only a single character. For example, the string abc is not special, whereas the string ddd, zz and f are special.\nReturn the length of the longest special substrings of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.\nA substrings is a contiguous non-empty sequence of characters within a string.\nExample test case 1:\r#\rInput: s = \u0026quot;aaaa\u0026quot; Output: 2\nExplanation:\nIf $k = 1$, so i have {{a}, {a}, {a}, {a}}, and repeat more than 3 times. Its a factible answer. If $k = 2$, so i have {{aa}, {aa}, {aa}}, and repeat more than 3 times. Its a factible answer and the best at moment. If $k = 3$, so i have {{aaa}, {aaa}}, and repeat more than 3 times. Its not a factible answer. Thoughts\r#\rOk, the substring must be contiguous and not empty, so the combinations must be adjacents chars. If i need calculate combinations that are adjacent on a string may be i can use sliding windows Ok, but for sliding window if i wanna pop and push chars from front or end to my temporal contiguos substrings of size k, the time complexity gonna up if i try to insert elements or chars on front. Remember that the operation += do it on a string, create a copy of the object. That\u0026rsquo;s occupied time and memory. So if i only want get a track of the chars that are on my window, i can use a deque\u0026lt;char\u0026gt; and pop or push fast. References:\r#\rlink to the original problem: https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/description/ "},{"id":7,"href":"/data-structures/graphs/","title":"Graphs","section":"Data Structures Problems","content":"\rGraph Problems\r#\rContent for Graph Problems goes here.\n"},{"id":8,"href":"/searching-and-sorting/","title":"Searching And Sorting Problems","section":"Home","content":"\rSearching and Sorting\r#\rTo understand this type of problem, we need to consider cases where a specific permutation of the array or vector might be beneficial for us. If such a permutation has the characteristic that its elements are ordered monotonically, we can implement a sorting algorithm to achieve this order.\nWhen it comes to the searching phase, it\u0026rsquo;s important to note that scanning an array of size n in the worst case takes $O(n)$ time. For large constraints, such as an array of size $10^9$, this becomes computationally infeasible, as scanning such an array empirically takes more than 1 second. Generally, if a solution takes too long to execute, it results in an error commonly known as TLE (Time Limit Exceeded).\nTable of Contents\r#\reasy sort problem "},{"id":9,"href":"/data-structures/segment-tree/","title":"Segment Tree","section":"Data Structures Problems","content":"\rSegment Tree\r#\rContent for Segment Tree problems goes here.\n"}]